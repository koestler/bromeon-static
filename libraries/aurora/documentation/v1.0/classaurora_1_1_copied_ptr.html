<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>aurora::CopiedPtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!--<script type="text/javascript" src="$relpath/search.js"></script>-->
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body> <!-- onload='searchBox.OnSelectItem(0);'> -->
<div id="header"><img src="../../../../bromeon.png" alt="Bromeon"/>
</div>
<div class="sidebar">
  <p><a href="../../../../index.html">Home</a></p>
  <p><a href="../../../../libraries/index.html">C++ Libraries</a></p>
  <div class="sb-sub">
    <p><a href="../../../thor/index.html">Thor</a></p>
    <p><a href="../../../aurora/index.html">Aurora</a></p>
    <div class="sb-sub2">
      <div class="sb-cur">
        <p><a href="../../documentation/index.html">Documentation</a></p>
      </div>
      <p><a href="../../download/index.html">Download</a></p>
      <p><a href="../../tutorials/index.html">Tutorials</a></p>
    </div>
  </div>
  <p><a href="../../../../games/index.html">Games</a></p>
  <p><a href="../../../../articles/index.html">Articles</a></p>
  <p><a href="../../../../book/index.html">Book</a></p>
  <p><a href="../../../../contact.html">Contact</a></p>
</div>
<!--
<div id="header"><img src="Bromeon.png" alt="Bromeon" />
</div>
<div id="sidebar">
  <p><a href="index.html">Home</a></p>
  <p><a href="thor.html">Thor C++ Library</a></p>
  <p><a href="doc/index.html">Documentation</a></p>
<p>Tutorials</p>
<p>Downloads</p>
</div>
-->
<div id="top"><!-- do not remove this div! -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>aurora</b></li><li class="navelem"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classaurora_1_1_copied_ptr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">aurora::CopiedPtr&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___smart_ptr.html">SmartPtr</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Copyable smart pointer template.  
 <a href="classaurora_1_1_copied_ptr.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a504bbc4fc48a7146d662b94c4ea2f455"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a504bbc4fc48a7146d662b94c4ea2f455">CopiedPtr</a> ()</td></tr>
<tr class="memdesc:a504bbc4fc48a7146d662b94c4ea2f455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a504bbc4fc48a7146d662b94c4ea2f455">More...</a><br /></td></tr>
<tr class="separator:a504bbc4fc48a7146d662b94c4ea2f455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e651279f06fcf4501f528dc921c83f8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a0e651279f06fcf4501f528dc921c83f8">CopiedPtr</a> (std::nullptr_t)</td></tr>
<tr class="memdesc:a0e651279f06fcf4501f528dc921c83f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from nullptr.  <a href="#a0e651279f06fcf4501f528dc921c83f8">More...</a><br /></td></tr>
<tr class="separator:a0e651279f06fcf4501f528dc921c83f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01058348fe8b40af2bd7b9e0ef91601"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ac01058348fe8b40af2bd7b9e0ef91601"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#ac01058348fe8b40af2bd7b9e0ef91601">CopiedPtr</a> (U *pointer)</td></tr>
<tr class="memdesc:ac01058348fe8b40af2bd7b9e0ef91601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from raw pointer.  <a href="#ac01058348fe8b40af2bd7b9e0ef91601">More...</a><br /></td></tr>
<tr class="separator:ac01058348fe8b40af2bd7b9e0ef91601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4703fe8b33c271f434a7b4ffdb89b3"><td class="memTemplParams" colspan="2">template&lt;typename U , typename C &gt; </td></tr>
<tr class="memitem:a2a4703fe8b33c271f434a7b4ffdb89b3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a2a4703fe8b33c271f434a7b4ffdb89b3">CopiedPtr</a> (U *pointer, C cloner)</td></tr>
<tr class="memdesc:a2a4703fe8b33c271f434a7b4ffdb89b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from raw pointer with cloner.  <a href="#a2a4703fe8b33c271f434a7b4ffdb89b3">More...</a><br /></td></tr>
<tr class="separator:a2a4703fe8b33c271f434a7b4ffdb89b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d20e72ca4c62d44f5848e69f85db775"><td class="memTemplParams" colspan="2">template&lt;typename U , typename C , typename D &gt; </td></tr>
<tr class="memitem:a8d20e72ca4c62d44f5848e69f85db775"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a8d20e72ca4c62d44f5848e69f85db775">CopiedPtr</a> (U *pointer, C cloner, D deleter)</td></tr>
<tr class="memdesc:a8d20e72ca4c62d44f5848e69f85db775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from raw pointer with cloner and deleter.  <a href="#a8d20e72ca4c62d44f5848e69f85db775">More...</a><br /></td></tr>
<tr class="separator:a8d20e72ca4c62d44f5848e69f85db775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8cea18fdd0116da73b0a310532cf7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a6b8cea18fdd0116da73b0a310532cf7d">CopiedPtr</a> (const <a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> &amp;origin)</td></tr>
<tr class="memdesc:a6b8cea18fdd0116da73b0a310532cf7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a6b8cea18fdd0116da73b0a310532cf7d">More...</a><br /></td></tr>
<tr class="separator:a6b8cea18fdd0116da73b0a310532cf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd3085441776aa3d5b342130e5be8a63"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:acd3085441776aa3d5b342130e5be8a63"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#acd3085441776aa3d5b342130e5be8a63">CopiedPtr</a> (const <a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; U &gt; &amp;origin)</td></tr>
<tr class="memdesc:acd3085441776aa3d5b342130e5be8a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from different CopiedPtr.  <a href="#acd3085441776aa3d5b342130e5be8a63">More...</a><br /></td></tr>
<tr class="separator:acd3085441776aa3d5b342130e5be8a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd7c99664db260385291b33b8af1cbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a9bd7c99664db260385291b33b8af1cbf">CopiedPtr</a> (<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> &amp;&amp;source)</td></tr>
<tr class="memdesc:a9bd7c99664db260385291b33b8af1cbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#a9bd7c99664db260385291b33b8af1cbf">More...</a><br /></td></tr>
<tr class="separator:a9bd7c99664db260385291b33b8af1cbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aadd460ad4121fc253a379fe5c266a1"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a4aadd460ad4121fc253a379fe5c266a1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a4aadd460ad4121fc253a379fe5c266a1">CopiedPtr</a> (<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; U &gt; &amp;&amp;source)</td></tr>
<tr class="memdesc:a4aadd460ad4121fc253a379fe5c266a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move from different CopiedPtr.  <a href="#a4aadd460ad4121fc253a379fe5c266a1">More...</a><br /></td></tr>
<tr class="separator:a4aadd460ad4121fc253a379fe5c266a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022ba4c0d11c7b22b05693d577e516bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a022ba4c0d11c7b22b05693d577e516bc">operator=</a> (const <a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> &amp;origin)</td></tr>
<tr class="memdesc:a022ba4c0d11c7b22b05693d577e516bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#a022ba4c0d11c7b22b05693d577e516bc">More...</a><br /></td></tr>
<tr class="separator:a022ba4c0d11c7b22b05693d577e516bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866316a1c7cffb569b5028daac36b3f6"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a866316a1c7cffb569b5028daac36b3f6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a866316a1c7cffb569b5028daac36b3f6">operator=</a> (const <a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; U &gt; &amp;origin)</td></tr>
<tr class="memdesc:a866316a1c7cffb569b5028daac36b3f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy-assign from different <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a>.  <a href="#a866316a1c7cffb569b5028daac36b3f6">More...</a><br /></td></tr>
<tr class="separator:a866316a1c7cffb569b5028daac36b3f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f05d386a332dc26e2954090e78053fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a6f05d386a332dc26e2954090e78053fe">operator=</a> (<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> &amp;&amp;source)</td></tr>
<tr class="memdesc:a6f05d386a332dc26e2954090e78053fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a6f05d386a332dc26e2954090e78053fe">More...</a><br /></td></tr>
<tr class="separator:a6f05d386a332dc26e2954090e78053fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b682507fbcf71547ddf9b6ac44eb114"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a2b682507fbcf71547ddf9b6ac44eb114"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a2b682507fbcf71547ddf9b6ac44eb114">operator=</a> (<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; U &gt; &amp;&amp;source)</td></tr>
<tr class="memdesc:a2b682507fbcf71547ddf9b6ac44eb114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move-assign from different <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a>.  <a href="#a2b682507fbcf71547ddf9b6ac44eb114">More...</a><br /></td></tr>
<tr class="separator:a2b682507fbcf71547ddf9b6ac44eb114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1feb96e96ac70218c82d2ff22daea8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#ac1feb96e96ac70218c82d2ff22daea8b">~CopiedPtr</a> ()</td></tr>
<tr class="memdesc:ac1feb96e96ac70218c82d2ff22daea8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ac1feb96e96ac70218c82d2ff22daea8b">More...</a><br /></td></tr>
<tr class="separator:ac1feb96e96ac70218c82d2ff22daea8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae316c3617ae347ef1159d861d5c71513"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae316c3617ae347ef1159d861d5c71513"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#ae316c3617ae347ef1159d861d5c71513">swap</a> (<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> &amp;other)</td></tr>
<tr class="memdesc:ae316c3617ae347ef1159d861d5c71513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exchanges the values of *this and <code>other</code>. <br /></td></tr>
<tr class="separator:ae316c3617ae347ef1159d861d5c71513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7cd41d20781f10de4f5e0347b0ff5cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7cd41d20781f10de4f5e0347b0ff5cd"></a>
T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#ad7cd41d20781f10de4f5e0347b0ff5cd">operator*</a> () const </td></tr>
<tr class="memdesc:ad7cd41d20781f10de4f5e0347b0ff5cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the pointer. <br /></td></tr>
<tr class="separator:ad7cd41d20781f10de4f5e0347b0ff5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c1700657821d3e20231c76611eef11"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae5c1700657821d3e20231c76611eef11"></a>
T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#ae5c1700657821d3e20231c76611eef11">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:ae5c1700657821d3e20231c76611eef11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the pointer for member access. <br /></td></tr>
<tr class="separator:ae5c1700657821d3e20231c76611eef11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa772a1ab6faab05ff96bff4dca653348"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#aa772a1ab6faab05ff96bff4dca653348">operator SafeBool</a> () const </td></tr>
<tr class="memdesc:aa772a1ab6faab05ff96bff4dca653348"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the smart pointer is not nullptr.  <a href="#aa772a1ab6faab05ff96bff4dca653348">More...</a><br /></td></tr>
<tr class="separator:aa772a1ab6faab05ff96bff4dca653348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e61052cbbcc6af65c8f4771f0a3971a"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a4e61052cbbcc6af65c8f4771f0a3971a">get</a> () const </td></tr>
<tr class="memdesc:a4e61052cbbcc6af65c8f4771f0a3971a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permits access to the internal pointer. Designed for rare use.  <a href="#a4e61052cbbcc6af65c8f4771f0a3971a">More...</a><br /></td></tr>
<tr class="separator:a4e61052cbbcc6af65c8f4771f0a3971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa5471b080448fe189990776ee3bdb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#adfa5471b080448fe189990776ee3bdb2">reset</a> ()</td></tr>
<tr class="memdesc:adfa5471b080448fe189990776ee3bdb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to null pointer.  <a href="#adfa5471b080448fe189990776ee3bdb2">More...</a><br /></td></tr>
<tr class="separator:adfa5471b080448fe189990776ee3bdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800bf78c0f436e7b914b1e0998e9a23e"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a800bf78c0f436e7b914b1e0998e9a23e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a800bf78c0f436e7b914b1e0998e9a23e">reset</a> (U *pointer)</td></tr>
<tr class="memdesc:a800bf78c0f436e7b914b1e0998e9a23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to raw pointer.  <a href="#a800bf78c0f436e7b914b1e0998e9a23e">More...</a><br /></td></tr>
<tr class="separator:a800bf78c0f436e7b914b1e0998e9a23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa3660cda6e27cbdc1f770b821e616b"><td class="memTemplParams" colspan="2">template&lt;typename U , typename C &gt; </td></tr>
<tr class="memitem:abaa3660cda6e27cbdc1f770b821e616b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#abaa3660cda6e27cbdc1f770b821e616b">reset</a> (U *pointer, C cloner)</td></tr>
<tr class="memdesc:abaa3660cda6e27cbdc1f770b821e616b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to raw pointer with cloner.  <a href="#abaa3660cda6e27cbdc1f770b821e616b">More...</a><br /></td></tr>
<tr class="separator:abaa3660cda6e27cbdc1f770b821e616b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05539671439736292c28344f426a004e"><td class="memTemplParams" colspan="2">template&lt;typename U , typename C , typename D &gt; </td></tr>
<tr class="memitem:a05539671439736292c28344f426a004e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaurora_1_1_copied_ptr.html#a05539671439736292c28344f426a004e">reset</a> (U *pointer, C cloner, D deleter)</td></tr>
<tr class="memdesc:a05539671439736292c28344f426a004e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset to raw pointer with cloner and deleter.  <a href="#a05539671439736292c28344f426a004e">More...</a><br /></td></tr>
<tr class="separator:a05539671439736292c28344f426a004e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:gad0d298909455fba47dc3b20f856f441b"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad0d298909455fba47dc3b20f856f441b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad0d298909455fba47dc3b20f856f441b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___smart_ptr.html#gad0d298909455fba47dc3b20f856f441b">swap</a> (<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; T &gt; &amp;lhs, <a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gad0d298909455fba47dc3b20f856f441b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the contents of two <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a> instances. <br /></td></tr>
<tr class="separator:gad0d298909455fba47dc3b20f856f441b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45c39ba19c82535dfd92c9047d4e85d5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga45c39ba19c82535dfd92c9047d4e85d5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___smart_ptr.html#ga45c39ba19c82535dfd92c9047d4e85d5">makeCopied</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga45c39ba19c82535dfd92c9047d4e85d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces an object directly inside the copied pointer.  <a href="group___smart_ptr.html#ga45c39ba19c82535dfd92c9047d4e85d5">More...</a><br /></td></tr>
<tr class="separator:ga45c39ba19c82535dfd92c9047d4e85d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class aurora::CopiedPtr&lt; T &gt;</h3>

<p>Copyable smart pointer template. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the stored pointee object. Can be void.</td></tr>
  </table>
  </dd>
</dl>
<p>This class supports automatic destruction and copying. It has full value semantics, i.e. the stored object is destroyed in the smart pointer's destructor and copied in the smart pointer's copy constructor. The concept of custom cloners and deleters allows you to specify the way how destructions and copies are performed. <br />
<br />
 This smart pointer is always unique, no two CopiedPtr instances share the same object. <br />
<br />
 Every operation provides at least the strong exception guarantee: When copies of the pointee object throw an exception, the smart pointer will remain in a valid (uncommitted) state and no memory will be leaked. Move construction and move assignment from the same CopiedPtr&lt;T&gt; type additionally offer the nothrow guarantee; they involve neither copies nor moves of the pointee object. Operations on empty smart pointers (such as default constructor, copies/moves from null pointers) also provide the nothrow guarantee; they never involve any dynamic allocation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a504bbc4fc48a7146d662b94c4ea2f455"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Initializes the smart pointer with a null pointer. </p>

</div>
</div>
<a class="anchor" id="a0e651279f06fcf4501f528dc921c83f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from nullptr. </p>
<p>Allows conversions from the <code>nullptr</code> literal to a <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a>. </p>

</div>
</div>
<a class="anchor" id="ac01058348fe8b40af2bd7b9e0ef91601"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from raw pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>Initial pointer value, can be nullptr. Must be convertible to T*. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a4703fe8b33c271f434a7b4ffdb89b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>cloner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from raw pointer with cloner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>Initial pointer value, can be nullptr. Must be convertible to T*. </td></tr>
    <tr><td class="paramname">cloner</td><td>Callable with signature <b>T*(const T*)</b> that is invoked during <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a> copies. Must return a pointer to a copy of the argument.</td></tr>
  </table>
  </dd>
</dl>
<p>Uses OperatorDelete&lt;U&gt; as deleter. Make sure your cloner returns an object allocated with new. </p>

</div>
</div>
<a class="anchor" id="a8d20e72ca4c62d44f5848e69f85db775"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename C , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>cloner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from raw pointer with cloner and deleter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>Initial pointer value, can be nullptr. Must be convertible to T*. </td></tr>
    <tr><td class="paramname">cloner</td><td>Callable with signature <b>T*(const T*)</b> that is invoked during <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a> copies. Must return a pointer to a copy of the argument. </td></tr>
    <tr><td class="paramname">deleter</td><td>Callable with signature <b>void(T*)</b> that is invoked during <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a> destruction. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b8cea18fdd0116da73b0a310532cf7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>Original smart pointer</td></tr>
  </table>
  </dd>
</dl>
<p>If the origin's pointer is <code>nullptr</code>, this pointer will also be <code>nullptr</code>. Otherwise, this instance will hold the pointer returned by the cloner. </p>

</div>
</div>
<a class="anchor" id="acd3085441776aa3d5b342130e5be8a63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from different CopiedPtr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>Original smart pointer, where U* convertible to T*. Can refer to a derived object.</td></tr>
  </table>
  </dd>
</dl>
<p>If the origin's pointer is <code>nullptr</code>, this pointer will also be <code>nullptr</code>. Otherwise, this instance will hold the pointer returned by the cloner. </p>

</div>
</div>
<a class="anchor" id="a9bd7c99664db260385291b33b8af1cbf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>RValue reference to object of which the ownership is taken. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4aadd460ad4121fc253a379fe5c266a1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move from different CopiedPtr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>RValue reference to object of which the ownership is taken.</td></tr>
  </table>
  </dd>
</dl>
<p>In contrast to the move constructor, this constructor does not offer the nothrow guarantee. Only strong exception guarantee is provided (because of an internal allocation; the pointee object is not copied). </p>

</div>
</div>
<a class="anchor" id="ac1feb96e96ac70218c82d2ff22daea8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::~<a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Invokes the deleter with the stored pointer as argument. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4e61052cbbcc6af65c8f4771f0a3971a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permits access to the internal pointer. Designed for rare use. </p>
<dl class="section return"><dt>Returns</dt><dd>Internally used pointer, use it wisely not to upset the <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a>'s memory management. </dd></dl>

</div>
</div>
<a class="anchor" id="aa772a1ab6faab05ff96bff4dca653348"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::operator SafeBool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the smart pointer is not nullptr. </p>
<p>Allows expressions of the form <code>if (ptr)</code> or <code>if (!ptr)</code>. </p><dl class="section return"><dt>Returns</dt><dd>Value convertible to true, if <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a> is not empty; value convertible to false otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a022ba4c0d11c7b22b05693d577e516bc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&amp; <a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>Original smart pointer</td></tr>
  </table>
  </dd>
</dl>
<p>Can imply a copy and a destruction, invoking origin's cloner and this deleter. </p>

</div>
</div>
<a class="anchor" id="a866316a1c7cffb569b5028daac36b3f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&amp; <a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy-assign from different <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>Original smart pointer, where U* convertible to T*. Can refer to a derived object.</td></tr>
  </table>
  </dd>
</dl>
<p>Can imply a copy and a destruction, invoking origin's cloner and this deleter. </p>

</div>
</div>
<a class="anchor" id="a6f05d386a332dc26e2954090e78053fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&amp; <a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>RValue reference to object of which the ownership is taken. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2b682507fbcf71547ddf9b6ac44eb114"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&amp; <a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaurora_1_1_copied_ptr.html">CopiedPtr</a>&lt; U &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move-assign from different <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>RValue reference to object of which the ownership is taken.</td></tr>
  </table>
  </dd>
</dl>
<p>In contrast to the move assignment operator, this assignment operator does not offer the nothrow guarantee. Only strong exception guarantee is provided (because of an internal allocation; the pointee object is not copied). </p>

</div>
</div>
<a class="anchor" id="adfa5471b080448fe189990776ee3bdb2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset to null pointer. </p>
<p>If this instance currently holds a pointer, the old deleter is invoked. </p>

</div>
</div>
<a class="anchor" id="a800bf78c0f436e7b914b1e0998e9a23e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset to raw pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>Initial pointer value, can be nullptr. Must be convertible to T*.</td></tr>
  </table>
  </dd>
</dl>
<p>If this instance currently holds a pointer, the old deleter is invoked. </p>

</div>
</div>
<a class="anchor" id="abaa3660cda6e27cbdc1f770b821e616b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>cloner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset to raw pointer with cloner. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>Initial pointer value, can be nullptr. Must be convertible to T*. </td></tr>
    <tr><td class="paramname">cloner</td><td>Callable with signature <b>T*(const T*)</b> that is invoked during <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a> copies. Must return a pointer to a copy of the argument.</td></tr>
  </table>
  </dd>
</dl>
<p>If this instance currently holds a pointer, the old deleter is invoked. <br />
 Uses OperatorDelete&lt;U&gt; as deleter. Make sure your cloner returns an object allocated with new. </p>

</div>
</div>
<a class="anchor" id="a05539671439736292c28344f426a004e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U , typename C , typename D &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classaurora_1_1_copied_ptr.html">aurora::CopiedPtr</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">U *&#160;</td>
          <td class="paramname"><em>pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C&#160;</td>
          <td class="paramname"><em>cloner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">D&#160;</td>
          <td class="paramname"><em>deleter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset to raw pointer with cloner and deleter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>Initial pointer value, can be nullptr. Must be convertible to T*. </td></tr>
    <tr><td class="paramname">cloner</td><td>Callable with signature <b>T*(const T*)</b> that is invoked during <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a> copies. Must return a pointer to a copy of the argument. </td></tr>
    <tr><td class="paramname">deleter</td><td>Callable with signature <b>void(T*)</b> that is invoked during <a class="el" href="classaurora_1_1_copied_ptr.html" title="Copyable smart pointer template. ">CopiedPtr</a> destruction.</td></tr>
  </table>
  </dd>
</dl>
<p>If this instance currently holds a pointer, the old deleter is invoked. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SmartPtr/<a class="el" href="_copied_ptr_8hpp_source.html">CopiedPtr.hpp</a></li>
</ul>
</div><!-- contents -->

<!--hr class="footer" /-->
<div id="footer">
  Copyright (c) Jan Haller 2011-2016
</div>
<!--
<address class="footer"><small>
Generated on Sun Jan 17 2016 23:02:44 for Thor by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10</small></address>
-->
</body>
</html>
