<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Meta</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!--<script type="text/javascript" src="$relpath/search.js"></script>-->
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body> <!-- onload='searchBox.OnSelectItem(0);'> -->
<div id="header"><img src="../../../../bromeon.png" alt="Bromeon"/>
</div>
<div class="sidebar">
  <p><a href="../../../../index.html">Home</a></p>
  <p><a href="../../../../libraries/index.html">C++ Libraries</a></p>
  <div class="sb-sub">
    <p><a href="../../../thor/index.html">Thor</a></p>
    <p><a href="../../../aurora/index.html">Aurora</a></p>
    <div class="sb-sub2">
      <div class="sb-cur">
        <p><a href="../../documentation/index.html">Documentation</a></p>
      </div>
      <p><a href="../../download/index.html">Download</a></p>
      <p><a href="../../tutorials/index.html">Tutorials</a></p>
    </div>
  </div>
  <p><a href="../../../../games/index.html">Games</a></p>
  <p><a href="../../../../articles/index.html">Articles</a></p>
  <p><a href="../../../../book/index.html">Book</a></p>
  <p><a href="../../../../contact.html">Contact</a></p>
</div>
<!--
<div id="header"><img src="Bromeon.png" alt="Bromeon" />
</div>
<div id="sidebar">
  <p><a href="index.html">Home</a></p>
  <p><a href="thor.html">Thor C++ Library</a></p>
  <p><a href="doc/index.html">Documentation</a></p>
<p>Tutorials</p>
<p>Downloads</p>
</div>
-->
<div id="top"><!-- do not remove this div! -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Meta</div>  </div>
</div><!--header-->
<div class="contents">

<p>Utilities for template and preprocessor metaprogramming.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_type.html">aurora::Type&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple type wrapper, can be used for overload resolution.  <a href="structaurora_1_1_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_int.html">aurora::Int&lt; N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple integer wrapper, can be used for overload resolution.  <a href="structaurora_1_1_int.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_function_result.html">aurora::FunctionResult&lt; Signature &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out the return type of a function.  <a href="structaurora_1_1_function_result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_function_param.html">aurora::FunctionParam&lt; Signature, N &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out the N-th parameter type of a function.  <a href="structaurora_1_1_function_param.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_function_arity.html">aurora::FunctionArity&lt; Signature &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out the number of parameters of a function.  <a href="structaurora_1_1_function_arity.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_typelist.html">aurora::Typelist&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class template to store a list of types.  <a href="structaurora_1_1_typelist.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_typelist_at.html">aurora::TypelistAt&lt; Types, Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Random access to type.  <a href="structaurora_1_1_typelist_at.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_typelist_find.html">aurora::TypelistFind&lt; Types, Searched &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find position of type in typelist.  <a href="structaurora_1_1_typelist_find.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_typelist_cat.html">aurora::TypelistCat&lt; LhsTypelist, RhsTypelist &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two typelists.  <a href="structaurora_1_1_typelist_cat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_typelist_contains.html">aurora::TypelistContains&lt; Typelist1, T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if type is part of typelist.  <a href="structaurora_1_1_typelist_contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga9953cb0969d70db9bb40a351a49fb729"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga9953cb0969d70db9bb40a351a49fb729">AURORA_PP_LIMIT</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:ga9953cb0969d70db9bb40a351a49fb729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit for preprocessor metaprogramming arguments.  <a href="#ga9953cb0969d70db9bb40a351a49fb729">More...</a><br /></td></tr>
<tr class="separator:ga9953cb0969d70db9bb40a351a49fb729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab7c9cc419c8f95f53519b554e3b53ec7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#gab7c9cc419c8f95f53519b554e3b53ec7">AURORA_PP_CAT</a>(a,  b)</td></tr>
<tr class="memdesc:gab7c9cc419c8f95f53519b554e3b53ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two expressions (evaluated ## operator)  <a href="#gab7c9cc419c8f95f53519b554e3b53ec7">More...</a><br /></td></tr>
<tr class="separator:gab7c9cc419c8f95f53519b554e3b53ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd40e62c62870b08f3ac6032c132e29f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#gacd40e62c62870b08f3ac6032c132e29f">AURORA_PP_STRINGIZE</a>(a)</td></tr>
<tr class="memdesc:gacd40e62c62870b08f3ac6032c132e29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert expression to string (evaluated # operator)  <a href="#gacd40e62c62870b08f3ac6032c132e29f">More...</a><br /></td></tr>
<tr class="separator:gacd40e62c62870b08f3ac6032c132e29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c353f17f18992c79645ed109de27eb1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga3c353f17f18992c79645ed109de27eb1">AURORA_PP_IF</a>(condition,  trueCase,  falseCase)</td></tr>
<tr class="memdesc:ga3c353f17f18992c79645ed109de27eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional evaluation.  <a href="#ga3c353f17f18992c79645ed109de27eb1">More...</a><br /></td></tr>
<tr class="separator:ga3c353f17f18992c79645ed109de27eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21e87274db634ed08b696dabe28794e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga21e87274db634ed08b696dabe28794e6">AURORA_PP_ENUMERATE</a>(n,  macro)</td></tr>
<tr class="memdesc:ga21e87274db634ed08b696dabe28794e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a macro repeated times.  <a href="#ga21e87274db634ed08b696dabe28794e6">More...</a><br /></td></tr>
<tr class="separator:ga21e87274db634ed08b696dabe28794e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7083ba135f61416e17bb57ba59a7d778"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga7083ba135f61416e17bb57ba59a7d778">AURORA_PP_ENUMERATE_COMMA</a>(n,  macro)</td></tr>
<tr class="memdesc:ga7083ba135f61416e17bb57ba59a7d778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a macro repeated times, comma-separated.  <a href="#ga7083ba135f61416e17bb57ba59a7d778">More...</a><br /></td></tr>
<tr class="separator:ga7083ba135f61416e17bb57ba59a7d778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2720590e5cbfe2bf98a463f05b93db22"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga2720590e5cbfe2bf98a463f05b93db22">AURORA_PP_COMMA_IF</a>(n)</td></tr>
<tr class="memdesc:ga2720590e5cbfe2bf98a463f05b93db22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comma if non-zero argument.  <a href="#ga2720590e5cbfe2bf98a463f05b93db22">More...</a><br /></td></tr>
<tr class="separator:ga2720590e5cbfe2bf98a463f05b93db22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga800e61567f75be1e1826ca265b187fff"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga800e61567f75be1e1826ca265b187fff">AURORA_PP_AT</a>(size,  n,  tuple)</td></tr>
<tr class="memdesc:ga800e61567f75be1e1826ca265b187fff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access element of tuple.  <a href="#ga800e61567f75be1e1826ca265b187fff">More...</a><br /></td></tr>
<tr class="separator:ga800e61567f75be1e1826ca265b187fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga601b1e44235559d98b223f72532727bb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga601b1e44235559d98b223f72532727bb">AURORA_PP_FOREACH</a>(macro,  tuple)</td></tr>
<tr class="memdesc:ga601b1e44235559d98b223f72532727bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply macro for each element in tuple.  <a href="#ga601b1e44235559d98b223f72532727bb">More...</a><br /></td></tr>
<tr class="separator:ga601b1e44235559d98b223f72532727bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga969c1d5f101cdef437e5e4e46ec64da0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga969c1d5f101cdef437e5e4e46ec64da0">AURORA_PP_FOREACH_DATA</a>(macro,  tuple,  data)</td></tr>
<tr class="memdesc:ga969c1d5f101cdef437e5e4e46ec64da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply macro for each element in tuple, with additional argument.  <a href="#ga969c1d5f101cdef437e5e4e46ec64da0">More...</a><br /></td></tr>
<tr class="separator:ga969c1d5f101cdef437e5e4e46ec64da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf0cb5dd775f49e4de7688efabe3dc4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga1cf0cb5dd775f49e4de7688efabe3dc4">AURORA_PP_POSITIVE_SIZE</a>(tuple)</td></tr>
<tr class="memdesc:ga1cf0cb5dd775f49e4de7688efabe3dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a non-empty preprocessor tuple.  <a href="#ga1cf0cb5dd775f49e4de7688efabe3dc4">More...</a><br /></td></tr>
<tr class="separator:ga1cf0cb5dd775f49e4de7688efabe3dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eabb32a877012d3c47e68cddedbca98"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga6eabb32a877012d3c47e68cddedbca98">AURORA_PP_SIZE</a>(tuple)</td></tr>
<tr class="memdesc:ga6eabb32a877012d3c47e68cddedbca98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size of a preprocessor tuple.  <a href="#ga6eabb32a877012d3c47e68cddedbca98">More...</a><br /></td></tr>
<tr class="separator:ga6eabb32a877012d3c47e68cddedbca98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1e1e3442443bfdf202b1f1bc5427e4e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#gaa1e1e3442443bfdf202b1f1bc5427e4e">AURORA_ENABLE_IF</a>(...)&#160;&#160;&#160;, typename std::enable_if&lt;__VA_ARGS__&gt;::type* = nullptr</td></tr>
<tr class="memdesc:gaa1e1e3442443bfdf202b1f1bc5427e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE Enable If Macro for parameter lists.  <a href="#gaa1e1e3442443bfdf202b1f1bc5427e4e">More...</a><br /></td></tr>
<tr class="separator:gaa1e1e3442443bfdf202b1f1bc5427e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c21a76b3e215f7053f3a6812b7d91e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#gaa0c21a76b3e215f7053f3a6812b7d91e">AURORA_REQUIRE_COMPLETE_TYPE</a>(Type)</td></tr>
<tr class="memdesc:gaa0c21a76b3e215f7053f3a6812b7d91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to ensure complete type.  <a href="#gaa0c21a76b3e215f7053f3a6812b7d91e">More...</a><br /></td></tr>
<tr class="separator:gaa0c21a76b3e215f7053f3a6812b7d91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga430a4c2fcb8c95057f4b0110801d46e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___meta.html#ga430a4c2fcb8c95057f4b0110801d46e7">AURORA_AUTO_RETURN</a>(...)&#160;&#160;&#160;decltype(__VA_ARGS__) { return (__VA_ARGS__); }</td></tr>
<tr class="memdesc:ga430a4c2fcb8c95057f4b0110801d46e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function declaration with inferred return type.  <a href="#ga430a4c2fcb8c95057f4b0110801d46e7">More...</a><br /></td></tr>
<tr class="separator:ga430a4c2fcb8c95057f4b0110801d46e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga27e3e06b33bd7cc45530e022e565bbd5"><td class="memTemplParams" colspan="2">template&lt;typename Result , typename Tuple &gt; </td></tr>
<tr class="memitem:ga27e3e06b33bd7cc45530e022e565bbd5"><td class="memTemplItemLeft" align="right" valign="top">Result *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___meta.html#ga27e3e06b33bd7cc45530e022e565bbd5">aurora::dynamicGet</a> (Tuple &amp;t, std::size_t i)</td></tr>
<tr class="memdesc:ga27e3e06b33bd7cc45530e022e565bbd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access tuple with dynamic index.  <a href="group___meta.html#ga27e3e06b33bd7cc45530e022e565bbd5">More...</a><br /></td></tr>
<tr class="separator:ga27e3e06b33bd7cc45530e022e565bbd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52ab455e2ec88dc6f52f95e74601ed5b"><td class="memTemplParams" colspan="2">template&lt;typename Transformer , typename SrcTuple &gt; </td></tr>
<tr class="memitem:ga52ab455e2ec88dc6f52f95e74601ed5b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___meta.html#ga52ab455e2ec88dc6f52f95e74601ed5b">aurora::tupleTransform</a> (const SrcTuple &amp;src) -&gt; InferredReturnType Transformer, std::tuple_size&lt; SrcTuple &gt;::value &gt;::apply(src))   template&lt; typename Tuple &gt; auto tupleFront(Tuple &amp;&amp;t) -&gt;       InferredReturnType   template&lt; typename Tuple &gt; auto tupleBack(Tuple &amp;&amp;t) -&gt;       InferredReturnType   template&lt; typename T, typename...Us &gt; T &amp;tupleGet(std::tuple&lt; Us... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:ga52ab455e2ec88dc6f52f95e74601ed5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform one tuple into another.  <a href="group___meta.html#ga52ab455e2ec88dc6f52f95e74601ed5b">More...</a><br /></td></tr>
<tr class="separator:ga52ab455e2ec88dc6f52f95e74601ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6fd027b3528f0efdb8c742d3b57da76"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename Function &gt; </td></tr>
<tr class="memitem:gac6fd027b3528f0efdb8c742d3b57da76"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___meta.html#gac6fd027b3528f0efdb8c742d3b57da76">aurora::foreach</a> (Function &amp;&amp;fn)</td></tr>
<tr class="memdesc:gac6fd027b3528f0efdb8c742d3b57da76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply function for each type in variadic parameter pack.  <a href="group___meta.html#gac6fd027b3528f0efdb8c742d3b57da76">More...</a><br /></td></tr>
<tr class="separator:gac6fd027b3528f0efdb8c742d3b57da76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32c9410e84ace2d5475ef29d7f5db853"><td class="memTemplParams" colspan="2">template&lt;typename... Ts, typename Function &gt; </td></tr>
<tr class="memitem:ga32c9410e84ace2d5475ef29d7f5db853"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___meta.html#ga32c9410e84ace2d5475ef29d7f5db853">aurora::foreach</a> (Function &amp;&amp;fn, Ts &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga32c9410e84ace2d5475ef29d7f5db853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply function for each value in variadic parameter pack.  <a href="group___meta.html#ga32c9410e84ace2d5475ef29d7f5db853">More...</a><br /></td></tr>
<tr class="separator:ga32c9410e84ace2d5475ef29d7f5db853"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Utilities for template and preprocessor metaprogramming. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga430a4c2fcb8c95057f4b0110801d46e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_AUTO_RETURN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;decltype(__VA_ARGS__) { return (__VA_ARGS__); }</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function declaration with inferred return type. </p>
<p>Based on the C++11 trailing return types feature. Since a lot of functions that benefit from trailing return types must repeat the return type by means of decltype, this macro has been written to avoid the code duplication. <br />
 Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;template &lt;typename A, typename B&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;auto sum(A a, B b) -&gt; AURORA_AUTO_RETURN(a + b)</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa1e1e3442443bfdf202b1f1bc5427e4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_ENABLE_IF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td>&#160;&#160;&#160;, typename std::enable_if&lt;__VA_ARGS__&gt;::type* = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SFINAE Enable If Macro for parameter lists. </p>
<p>Usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;template &lt;typename T&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;void Function(T value</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    AURORA_ENABLE_IF(std::is_integral&lt;T&gt;::value));</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga800e61567f75be1e1826ca265b187fff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_AT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">size, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tuple&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access element of tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>Size of the tuple. Can be inferred using <a class="el" href="group___meta.html#ga6eabb32a877012d3c47e68cddedbca98">AURORA_PP_SIZE</a>. </td></tr>
    <tr><td class="paramname">n</td><td>Index of the element to access, 0 &lt;= n &lt; size </td></tr>
    <tr><td class="paramname">tuple</td><td>Preprocessor tuple such as (a, b, c)</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the n-th element of a tuple. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AURORA_PP_AT(3, 0, (a, b, c)) == a</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AURORA_PP_AT(3, 1, (a, b, c)) == b</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;AURORA_PP_AT(3, 2, (a, b, c)) == c</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gab7c9cc419c8f95f53519b554e3b53ec7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_CAT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two expressions (evaluated ## operator) </p>
<p>This macro does the same as the built-in ## preprocessor operator, however the arguments are expanded before concatenation. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define FIRST  [evaluated 1st]</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define SECOND [evaluated 2nd]</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#define LAZY_CAT() FIRST ## SECOND</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;#define EXP_CAT()  AURORA_PP_CAT(FIRST, SECOND)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;// Comparison between ## and Aurora&#39;s catenation macro</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;LAZY_CAT()  // generates FIRSTSECOND</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;EXP_CAT()   // generates [evaluated 1st][evaluated 2nd]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga2720590e5cbfe2bf98a463f05b93db22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_COMMA_IF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comma if non-zero argument. </p>
<p>Evaluates to a comma if n is positive, and to nothing if n is zero. </p>

</div>
</div>
<a class="anchor" id="ga21e87274db634ed08b696dabe28794e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_ENUMERATE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">macro&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a macro repeated times. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of invocations </td></tr>
    <tr><td class="paramname">macro</td><td>Macro with signature <code>macro(index)</code>, where <code>index</code> is a number from 0 to n-1.</td></tr>
  </table>
  </dd>
</dl>
<p>Invokes the macro n times, passing it the indices from 0 to n-1 in this order. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define GENERATOR(index) [index]</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;AURORA_PP_ENUMERATE(4, GENERATOR)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// generates:</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;[0] [1] [2] [3]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga7083ba135f61416e17bb57ba59a7d778"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_ENUMERATE_COMMA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">n, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">macro&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a macro repeated times, comma-separated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Number of invocations </td></tr>
    <tr><td class="paramname">macro</td><td>Macro with signature <code>macro(index)</code>, where <code>index</code> is a number from 0 to n-1.</td></tr>
  </table>
  </dd>
</dl>
<p>Invokes the macro n times, passing it the indices from 0 to n-1 in this order. Puts a comma between each invocation. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define GENERATOR(index) [index]</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;AURORA_PP_ENUMERATE_COMMA(4, GENERATOR)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;// generates:</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;[0], [1], [2], [3]</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga601b1e44235559d98b223f72532727bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_FOREACH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">macro, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tuple&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply macro for each element in tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">macro</td><td>Macro with signature <code>macro(value, index)</code>, where <code>value</code> is the current element of the tuple and <code>index</code> is its index as a number from 0 to n-1. </td></tr>
    <tr><td class="paramname">tuple</td><td>Parenthesized tuple, such as (a, b, c). May be empty.</td></tr>
  </table>
  </dd>
</dl>
<p>Applies a macro repeated times, passing it every element in a tuple. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define MACRO(value, index)  [index]-&gt;value</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define TUPLE                (first, second, third)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;AURORA_PP_FOREACH(MACRO, TUPLE)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// generates:</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;[0]-&gt;first</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;[1]-&gt;second</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;[2]-&gt;third</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga969c1d5f101cdef437e5e4e46ec64da0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_FOREACH_DATA</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">macro, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tuple, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">data&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply macro for each element in tuple, with additional argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">macro</td><td>Macro with signature <code>macro(value, index, data)</code>, where <code>value</code> is the current element of the tuple, <code>index</code> is its index as a number from 0 to n-1, and <code>data</code> is the additional argument being forwarded. </td></tr>
    <tr><td class="paramname">tuple</td><td>Parenthesized tuple, such as (a, b, c). May be empty. </td></tr>
    <tr><td class="paramname">data</td><td>Additional argument to forward.</td></tr>
  </table>
  </dd>
</dl>
<p>Applies a macro repeated times, passing it every element in a tuple. Additional data can be specified that doesn't affect the repetition, but is passed to each macro invocation as an additional argument. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define MACRO(value, index, data)  [index]-&gt;(value, data)</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define TUPLE                      (first, second, third)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;AURORA_PP_FOREACH_DATA(MACRO, TUPLE, 42)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// generates:</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;[0]-&gt;(first, 42)</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;[1]-&gt;(second, 42)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;[2]-&gt;(third, 42)</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga3c353f17f18992c79645ed109de27eb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_IF</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">condition, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">trueCase, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">falseCase&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Conditional evaluation. </p>
<p>If <code>condition</code> evaluates to a positive number, then the expression will be replaced with <code>trueCase</code>. If <code>condition</code> is zero, then it will be <code>falseCase</code>. <br />
<br />
 When you use function style macros for <code>trueCase</code> and <code>falseCase</code>, put the argument list after the invocation, i.e. AURORA_PP_IF(...)(args) </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AURORA_PP_IF(0, true, false) == false</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AURORA_PP_IF(1, true, false) == true</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;AURORA_PP_IF(2, true, false) == true</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;AURORA_PP_IF(3, true, false) == true</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga9953cb0969d70db9bb40a351a49fb729"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_LIMIT&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limit for preprocessor metaprogramming arguments. </p>
<p>This number is the maximum size of preprocessor tuples and the highest number that can be passed to repetition macros. </p>

</div>
</div>
<a class="anchor" id="ga1cf0cb5dd775f49e4de7688efabe3dc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_POSITIVE_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tuple</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of a non-empty preprocessor tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Preprocessor tuple such as (a, b, c), of which the size is inferred.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a non-zero number of elements in a tuple. Use this macro whenever you are sure that a tuple will not be empty. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AURORA_PP_POSITIVE_SIZE( () )     == undefined</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AURORA_PP_POSITIVE_SIZE( (a) )    == 1</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;AURORA_PP_POSITIVE_SIZE( (a, b) ) == 2</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;AURORA_PP_POSITIVE_SIZE( (()) )   == 1</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga6eabb32a877012d3c47e68cddedbca98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_SIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tuple</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size of a preprocessor tuple. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>Preprocessor tuple such as (a, b, c), of which the size is inferred.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns the number of elements in a tuple. The size inference may fail in special cases with nested macros. If you are sure that a tuple is non-empty, use <a class="el" href="group___meta.html#ga1cf0cb5dd775f49e4de7688efabe3dc4">AURORA_PP_POSITIVE_SIZE</a> instead, which is simpler and more robust. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;AURORA_PP_SIZE( () )     == 0</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AURORA_PP_SIZE( (a) )    == 1</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;AURORA_PP_SIZE( (a, b) ) == 2</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;AURORA_PP_SIZE( (()) )   == 1</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gacd40e62c62870b08f3ac6032c132e29f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_PP_STRINGIZE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert expression to string (evaluated # operator) </p>
<p>This macro does the same as the built-in # preprocessor operator, however the argument is expanded before stringization. </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;#define MACRO(expr) [evaluated expr]</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define LAZY_STRINGIZE(expr) #expr</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;#define EXP_STRINGIZE(expr)  AURORA_PP_STRINGIZE(expr)</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;// Comparison between # and Aurora&#39;s stringize macro</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;LAZY_STRINGIZE(MACRO(42))  // generates &quot;MACRO(42)&quot;</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;EXP_STRINGIZE(MACRO(42))   // generates &quot;[evaluated 42]&quot;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaa0c21a76b3e215f7053f3a6812b7d91e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_REQUIRE_COMPLETE_TYPE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Type</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro to ensure complete type. </p>
<p>Usage: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;template &lt;typename T&gt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;void CheckedDelete(T* pointer)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    AURORA_REQUIRE_COMPLETE_TYPE(T);</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    delete pointer;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;}</div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga27e3e06b33bd7cc45530e022e565bbd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result* aurora::dynamicGet </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access tuple with dynamic index. </p>
<p>Usually, you can only access std::tuple by means of std::get&lt;N&gt;, where N must be a constant expression. This function allows you to pass a dynamic index. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Result</td><td>A type to which every element in the tuple is convertible, e.g. pointer to common base class. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The tuple of which you want to get an element </td></tr>
    <tr><td class="paramname">i</td><td>The index of the element, can be known at runtime </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac6fd027b3528f0efdb8c742d3b57da76"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aurora::foreach </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply function for each type in variadic parameter pack. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Ts</td><td>List of types to iterate through. Can also be a single type of aurora::Typelist&lt;...&gt;. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>Function object with a member function template <b>void operator() ()</b>.</td></tr>
  </table>
  </dd>
</dl>
<p>For each type <code>T</code> in <code>Ts</code>, the <code>fn's</code> operator() is called with explicit template argument <code>T</code>. Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Example</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator() ()</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">aurora::foreach&lt;int, float&gt;(Example()); <span class="comment">// output: &quot;int float&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga32c9410e84ace2d5475ef29d7f5db853"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts, typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aurora::foreach </td>
          <td>(</td>
          <td class="paramtype">Function &amp;&amp;&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Ts &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply function for each value in variadic parameter pack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>Function object with a member function template <b>void operator() (T&amp; value)</b>, or C++14 generic lambda. The parameter must be compatible to type <code>T</code>, however pass by value or by (const) (lvalue|rvalue) reference is allowed. </td></tr>
    <tr><td class="paramname">args</td><td>Arguments to iterate through.</td></tr>
  </table>
  </dd>
</dl>
<p>For each argument <code>arg</code> in <code>args</code>, the expression <b>fn(arg)</b> is evaluated. Example: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Example</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line">    <span class="keywordtype">void</span> operator() (<span class="keyword">const</span> T&amp; arg)</div>
<div class="line">    {</div>
<div class="line">        std::cout &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="charliteral">&#39;=&#39;</span> &lt;&lt; arg &lt;&lt; <span class="charliteral">&#39; &#39;</span>;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><a class="code" href="group___meta.html#gac6fd027b3528f0efdb8c742d3b57da76">aurora::foreach</a>(Example(), 4, 3.25f); <span class="comment">// output: &quot;int=4 float=3.25&quot;</span></div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga52ab455e2ec88dc6f52f95e74601ed5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Transformer , typename SrcTuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto aurora::tupleTransform </td>
          <td>(</td>
          <td class="paramtype">const SrcTuple &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td> -&gt; InferredReturnType Transformer, std::tuple_size&lt;SrcTuple&gt;::value&gt;::apply(src) )


template &lt;typename Tuple&gt;
auto tupleFront(Tuple&amp;&amp; t) -&gt; 


InferredReturnType


template &lt;typename Tuple&gt;
auto tupleBack(Tuple&amp;&amp; t) -&gt; 


InferredReturnType


template &lt;typename T, typename... Us&gt;
T&amp; tupleGet(std::tuple&lt;Us...&gt;&amp; tuple)
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform one tuple into another. </p>
<p>Transforms each element of a tuple using a given function. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Transformer</td><td>Class that has a method <code>static R transform(T element)</code> that takes an element of the source tuple and returns a corresponding value of the new tuple. <code>transform()</code> can be a function template to account for different element types. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Input tuple being transformed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output tuple, result of the transform. Has the same size as <code>src</code>, but possibly different element types.</dd></dl>
<p>Example code: </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ToDouble</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">static</span> <span class="keywordtype">double</span> transform(<span class="keywordtype">int</span> i)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> 2.5 * i;</div>
<div class="line">    }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line"><span class="keyword">auto</span> tuple = std::make_tuple(1, 2, 4);</div>
<div class="line"><span class="keyword">auto</span> result = aurora::tupleTransform&lt;ToDouble&gt;(tuple);</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->

<!--hr class="footer" /-->
<div id="footer">
  Copyright (c) Jan Haller 2011-2016
</div>
<!--
<address class="footer"><small>
Generated on Sun Jan 17 2016 23:02:43 for Thor by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10</small></address>
-->
</body>
</html>
