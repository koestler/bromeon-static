<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Tools</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!--<script type="text/javascript" src="$relpath/search.js"></script>-->
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body> <!-- onload='searchBox.OnSelectItem(0);'> -->
<div id="header"><img src="../../../../bromeon.png" alt="Bromeon"/>
</div>
<div class="sidebar">
  <p><a href="../../../../index.html">Home</a></p>
  <p><a href="../../../../libraries/index.html">C++ Libraries</a></p>
  <div class="sb-sub">
    <p><a href="../../../thor/index.html">Thor</a></p>
    <p><a href="../../../aurora/index.html">Aurora</a></p>
    <div class="sb-sub2">
      <div class="sb-cur">
        <p><a href="../../documentation/index.html">Documentation</a></p>
      </div>
      <p><a href="../../download/index.html">Download</a></p>
      <p><a href="../../tutorials/index.html">Tutorials</a></p>
    </div>
  </div>
  <p><a href="../../../../games/index.html">Games</a></p>
  <p><a href="../../../../articles/index.html">Articles</a></p>
  <p><a href="../../../../book/index.html">Book</a></p>
  <p><a href="../../../../contact.html">Contact</a></p>
</div>
<!--
<div id="header"><img src="Bromeon.png" alt="Bromeon" />
</div>
<div id="sidebar">
  <p><a href="index.html">Home</a></p>
  <p><a href="thor.html">Thor C++ Library</a></p>
  <p><a href="doc/index.html">Documentation</a></p>
<p>Tutorials</p>
<p>Downloads</p>
</div>
-->
<div id="top"><!-- do not remove this div! -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Tools</div>  </div>
</div><!--header-->
<div class="contents">

<p>C++ utility and idioms, such as noncopyable base classes, foreach macros or safe bool idiom.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_any.html">aurora::Any</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-erased class holding any value.  <a href="classaurora_1_1_any.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_exception.html">aurora::Exception</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception base class.  <a href="classaurora_1_1_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_function_call_exception.html">aurora::FunctionCallException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception class for failed function calls.  <a href="classaurora_1_1_function_call_exception.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_pair_hasher.html">aurora::PairHasher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash object for std::pair.  <a href="structaurora_1_1_pair_hasher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_non_copyable.html">aurora::NonCopyable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non-copyable base class.  <a href="classaurora_1_1_non_copyable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_nullopt_type.html">aurora::NulloptType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null literal for optional objects.  <a href="structaurora_1_1_nullopt_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structaurora_1_1_inplace_type.html">aurora::InplaceType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag to construct optional objects in-place.  <a href="structaurora_1_1_inplace_type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_optional.html">aurora::Optional&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents optional values.  <a href="classaurora_1_1_optional.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaurora_1_1_p_impl.html">aurora::PImpl&lt; T, Size, Align &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast PImpl idiom.  <a href="classaurora_1_1_p_impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa96508df6697039877c7508f2c98a539"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#gaa96508df6697039877c7508f2c98a539">AURORA_FOREACH</a>(declaration,  container)</td></tr>
<tr class="memdesc:gaa96508df6697039877c7508f2c98a539"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro that emulates C++11 range-based for loop.  <a href="#gaa96508df6697039877c7508f2c98a539">More...</a><br /></td></tr>
<tr class="separator:gaa96508df6697039877c7508f2c98a539"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eabdd0b9a6496bb8f00c8d073e6cd79"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#ga3eabdd0b9a6496bb8f00c8d073e6cd79">AURORA_NT_EQUAL</a>(TupleName,  typeVarPairs)</td></tr>
<tr class="memdesc:ga3eabdd0b9a6496bb8f00c8d073e6cd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator == for named tuples.  <a href="#ga3eabdd0b9a6496bb8f00c8d073e6cd79">More...</a><br /></td></tr>
<tr class="separator:ga3eabdd0b9a6496bb8f00c8d073e6cd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac03a3f07e3e9703a2932ad5396dbee94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#gac03a3f07e3e9703a2932ad5396dbee94">AURORA_NT_LESS</a>(TupleName,  typeVarPairs)</td></tr>
<tr class="memdesc:gac03a3f07e3e9703a2932ad5396dbee94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison operator &lt; for named tuples.  <a href="#gac03a3f07e3e9703a2932ad5396dbee94">More...</a><br /></td></tr>
<tr class="separator:gac03a3f07e3e9703a2932ad5396dbee94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e0d50fb1008002ba6dac10f3be167fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#ga9e0d50fb1008002ba6dac10f3be167fa">AURORA_NT_HASHER</a>(TupleName,  typeVarPairs)</td></tr>
<tr class="memdesc:ga9e0d50fb1008002ba6dac10f3be167fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hash functor for named tuples.  <a href="#ga9e0d50fb1008002ba6dac10f3be167fa">More...</a><br /></td></tr>
<tr class="separator:ga9e0d50fb1008002ba6dac10f3be167fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73d7061fe6c18f98be007687ab80b26c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#ga73d7061fe6c18f98be007687ab80b26c">AURORA_NT_DEFAULT_CTOR</a>(TupleName,  typeVarPairs)</td></tr>
<tr class="memdesc:ga73d7061fe6c18f98be007687ab80b26c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for named tuples.  <a href="#ga73d7061fe6c18f98be007687ab80b26c">More...</a><br /></td></tr>
<tr class="separator:ga73d7061fe6c18f98be007687ab80b26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6138d31f634740595bd3165302b261d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#ga6138d31f634740595bd3165302b261d3">AURORA_NAMED_TUPLE</a>(TupleName,  typeVarPairs)</td></tr>
<tr class="memdesc:ga6138d31f634740595bd3165302b261d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Named tuple definition.  <a href="#ga6138d31f634740595bd3165302b261d3">More...</a><br /></td></tr>
<tr class="separator:ga6138d31f634740595bd3165302b261d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfe2358c9b73b857434abe40a863eb61"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#gabfe2358c9b73b857434abe40a863eb61">AURORA_NAMED_TUPLE_EXT</a>(TupleName,  typeVarPairs,  extensions)</td></tr>
<tr class="memdesc:gabfe2358c9b73b857434abe40a863eb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Named tuple definition with extended functionality.  <a href="#gabfe2358c9b73b857434abe40a863eb61">More...</a><br /></td></tr>
<tr class="separator:gabfe2358c9b73b857434abe40a863eb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad856776103175a93968221ee22469bf4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#gad856776103175a93968221ee22469bf4">AURORA_GLOBAL_SWAP</a>(Class)</td></tr>
<tr class="memdesc:gad856776103175a93968221ee22469bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Macro to implement a global overload of <code>swap(lhs, rhs)</code> to allow argument-dependent lookup.  <a href="#gad856776103175a93968221ee22469bf4">More...</a><br /></td></tr>
<tr class="separator:gad856776103175a93968221ee22469bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1e24a9a5dee7e1593d1217d843c222f5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1e24a9a5dee7e1593d1217d843c222f5"></a>
typedef void(detail::SafeBoolHolder::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#ga1e24a9a5dee7e1593d1217d843c222f5">aurora::SafeBool</a>) ()</td></tr>
<tr class="memdesc:ga1e24a9a5dee7e1593d1217d843c222f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SafeBool type. <br /></td></tr>
<tr class="separator:ga1e24a9a5dee7e1593d1217d843c222f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gae76851fa9c764a9a6b2ba121c600b703"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae76851fa9c764a9a6b2ba121c600b703"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#gae76851fa9c764a9a6b2ba121c600b703">aurora::equivalent</a> (const T &amp;lhs, const T &amp;rhs)</td></tr>
<tr class="memdesc:gae76851fa9c764a9a6b2ba121c600b703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether two values are considered equivalent in sorting.  <a href="group___tools.html#gae76851fa9c764a9a6b2ba121c600b703">More...</a><br /></td></tr>
<tr class="separator:gae76851fa9c764a9a6b2ba121c600b703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2356b9cf59292cfc68ba2bb06127394"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:gae2356b9cf59292cfc68ba2bb06127394"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#gae2356b9cf59292cfc68ba2bb06127394">aurora::binarySearch</a> (ForwardIterator first, ForwardIterator last, const T &amp;value)</td></tr>
<tr class="memdesc:gae2356b9cf59292cfc68ba2bb06127394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary search for value in iterator range.  <a href="group___tools.html#gae2356b9cf59292cfc68ba2bb06127394">More...</a><br /></td></tr>
<tr class="separator:gae2356b9cf59292cfc68ba2bb06127394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbc61ba01e3e5ca2d9165a74b328eff8"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Iterator &gt; </td></tr>
<tr class="memitem:gadbc61ba01e3e5ca2d9165a74b328eff8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#gadbc61ba01e3e5ca2d9165a74b328eff8">aurora::eraseUnordered</a> (Container &amp;c, Iterator itr)</td></tr>
<tr class="memdesc:gadbc61ba01e3e5ca2d9165a74b328eff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase element using swap-and-pop_back idiom.  <a href="group___tools.html#gadbc61ba01e3e5ca2d9165a74b328eff8">More...</a><br /></td></tr>
<tr class="separator:gadbc61ba01e3e5ca2d9165a74b328eff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cf7ec4903809d8f39ab30abdb0f0988"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Value &gt; </td></tr>
<tr class="memitem:ga9cf7ec4903809d8f39ab30abdb0f0988"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga9cf7ec4903809d8f39ab30abdb0f0988">aurora::remove</a> (Container &amp;c, const Value &amp;v)</td></tr>
<tr class="memdesc:ga9cf7ec4903809d8f39ab30abdb0f0988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase-remove idiom.  <a href="group___tools.html#ga9cf7ec4903809d8f39ab30abdb0f0988">More...</a><br /></td></tr>
<tr class="separator:ga9cf7ec4903809d8f39ab30abdb0f0988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb66a2469b6e1cad65b955d269fbb4d1"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename Predicate &gt; </td></tr>
<tr class="memitem:gabb66a2469b6e1cad65b955d269fbb4d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#gabb66a2469b6e1cad65b955d269fbb4d1">aurora::removeIf</a> (Container &amp;c, const Predicate &amp;p)</td></tr>
<tr class="memdesc:gabb66a2469b6e1cad65b955d269fbb4d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase-remove-if idiom.  <a href="group___tools.html#gabb66a2469b6e1cad65b955d269fbb4d1">More...</a><br /></td></tr>
<tr class="separator:gabb66a2469b6e1cad65b955d269fbb4d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga759df97003e1beb0b9a2501805e0eca6"><td class="memTemplParams" colspan="2">template&lt;typename Queue &gt; </td></tr>
<tr class="memitem:ga759df97003e1beb0b9a2501805e0eca6"><td class="memTemplItemLeft" align="right" valign="top">Queue::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga759df97003e1beb0b9a2501805e0eca6">aurora::pop</a> (Queue &amp;q)</td></tr>
<tr class="memdesc:ga759df97003e1beb0b9a2501805e0eca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop from queue with return value.  <a href="group___tools.html#ga759df97003e1beb0b9a2501805e0eca6">More...</a><br /></td></tr>
<tr class="separator:ga759df97003e1beb0b9a2501805e0eca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43736a4dea0944c8b0c734775a7e95c"><td class="memTemplParams" colspan="2">template&lt;typename Queue &gt; </td></tr>
<tr class="memitem:gae43736a4dea0944c8b0c734775a7e95c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#gae43736a4dea0944c8b0c734775a7e95c">aurora::clearQueue</a> (Queue &amp;q)</td></tr>
<tr class="memdesc:gae43736a4dea0944c8b0c734775a7e95c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear std::queue.  <a href="group___tools.html#gae43736a4dea0944c8b0c734775a7e95c">More...</a><br /></td></tr>
<tr class="separator:gae43736a4dea0944c8b0c734775a7e95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga221d90caecf195f0613d6a91045abb8b"><td class="memTemplParams" colspan="2">template&lt;typename AssocContainer , typename Key &gt; </td></tr>
<tr class="memitem:ga221d90caecf195f0613d6a91045abb8b"><td class="memTemplItemLeft" align="right" valign="top">AssocContainer::mapped_type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga221d90caecf195f0613d6a91045abb8b">aurora::mapAt</a> (AssocContainer &amp;map, const Key &amp;k)</td></tr>
<tr class="memdesc:ga221d90caecf195f0613d6a91045abb8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value type for a specific key.  <a href="group___tools.html#ga221d90caecf195f0613d6a91045abb8b">More...</a><br /></td></tr>
<tr class="separator:ga221d90caecf195f0613d6a91045abb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aae4a4cf8c6ec37cfd54a4f2dc4aaf6"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga8aae4a4cf8c6ec37cfd54a4f2dc4aaf6"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga8aae4a4cf8c6ec37cfd54a4f2dc4aaf6">aurora::downcast</a> (From &amp;base)</td></tr>
<tr class="memdesc:ga8aae4a4cf8c6ec37cfd54a4f2dc4aaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe polymorphic downcast for references.  <a href="group___tools.html#ga8aae4a4cf8c6ec37cfd54a4f2dc4aaf6">More...</a><br /></td></tr>
<tr class="separator:ga8aae4a4cf8c6ec37cfd54a4f2dc4aaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e8dbf1c8d81ee5a15a815c3197c36f3"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:ga3e8dbf1c8d81ee5a15a815c3197c36f3"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga3e8dbf1c8d81ee5a15a815c3197c36f3">aurora::downcast</a> (From *base)</td></tr>
<tr class="memdesc:ga3e8dbf1c8d81ee5a15a815c3197c36f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe polymorphic downcast for pointers.  <a href="group___tools.html#ga3e8dbf1c8d81ee5a15a815c3197c36f3">More...</a><br /></td></tr>
<tr class="separator:ga3e8dbf1c8d81ee5a15a815c3197c36f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6e4b64987fae055a76a4610bee08875"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae6e4b64987fae055a76a4610bee08875"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae6e4b64987fae055a76a4610bee08875"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#gae6e4b64987fae055a76a4610bee08875">aurora::hashValue</a> (const T &amp;object)</td></tr>
<tr class="memdesc:gae6e4b64987fae055a76a4610bee08875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the hash value of an object (short-hand notation). <br /></td></tr>
<tr class="separator:gae6e4b64987fae055a76a4610bee08875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a8bcbdf06d4e7980a37aef879d75cce"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga5a8bcbdf06d4e7980a37aef879d75cce"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5a8bcbdf06d4e7980a37aef879d75cce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga5a8bcbdf06d4e7980a37aef879d75cce">aurora::hashCombine</a> (std::size_t &amp;seed, const T &amp;object)</td></tr>
<tr class="memdesc:ga5a8bcbdf06d4e7980a37aef879d75cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a hash with the hash value of another object. <br /></td></tr>
<tr class="separator:ga5a8bcbdf06d4e7980a37aef879d75cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40cbfe1174c9cf51756fe0f1690479d2"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga40cbfe1174c9cf51756fe0f1690479d2"></a>
template&lt;typename Itr &gt; </td></tr>
<tr class="memitem:ga40cbfe1174c9cf51756fe0f1690479d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga40cbfe1174c9cf51756fe0f1690479d2">aurora::hashRange</a> (std::size_t &amp;seed, Itr begin, Itr end)</td></tr>
<tr class="memdesc:ga40cbfe1174c9cf51756fe0f1690479d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines a hash with the hash value of a range of objects. <br /></td></tr>
<tr class="separator:ga40cbfe1174c9cf51756fe0f1690479d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac69731b2b792315d78b1a5948b95c516"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gac69731b2b792315d78b1a5948b95c516"></a>
SafeBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#gac69731b2b792315d78b1a5948b95c516">aurora::toSafeBool</a> (bool condition)</td></tr>
<tr class="memdesc:gac69731b2b792315d78b1a5948b95c516"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion function from bool to SafeBool. <br /></td></tr>
<tr class="separator:gac69731b2b792315d78b1a5948b95c516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8dc7698168e82026e52320b83d647fd"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad8dc7698168e82026e52320b83d647fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#gad8dc7698168e82026e52320b83d647fd">adlSwap</a> (T &amp;lhs, T &amp;rhs)</td></tr>
<tr class="memdesc:gad8dc7698168e82026e52320b83d647fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap() function with argument-dependent lookup  <a href="#gad8dc7698168e82026e52320b83d647fd">More...</a><br /></td></tr>
<tr class="separator:gad8dc7698168e82026e52320b83d647fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47a267cff5ab30391db8237a63a58dd3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga47a267cff5ab30391db8237a63a58dd3"><td class="memTemplItemLeft" align="right" valign="top">std::type_index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga47a267cff5ab30391db8237a63a58dd3">aurora::typeIndex</a> (T &amp;reference)</td></tr>
<tr class="memdesc:ga47a267cff5ab30391db8237a63a58dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe typeid operator for references.  <a href="group___tools.html#ga47a267cff5ab30391db8237a63a58dd3">More...</a><br /></td></tr>
<tr class="separator:ga47a267cff5ab30391db8237a63a58dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed775a738be90f56656000c5157196f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaed775a738be90f56656000c5157196f8"><td class="memTemplItemLeft" align="right" valign="top">std::type_index&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#gaed775a738be90f56656000c5157196f8">aurora::typeIndex</a> ()</td></tr>
<tr class="memdesc:gaed775a738be90f56656000c5157196f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe typeid operator for types.  <a href="group___tools.html#gaed775a738be90f56656000c5157196f8">More...</a><br /></td></tr>
<tr class="separator:gaed775a738be90f56656000c5157196f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga20033046629a9e400757ddda0600f382"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga20033046629a9e400757ddda0600f382"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga20033046629a9e400757ddda0600f382"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga20033046629a9e400757ddda0600f382">swap</a> (Optional&lt; T &gt; &amp;lhs, Optional&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga20033046629a9e400757ddda0600f382"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two optionals. <br /></td></tr>
<tr class="separator:ga20033046629a9e400757ddda0600f382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cc6a885a16bffa80423f7b8a3d7bd1a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:ga8cc6a885a16bffa80423f7b8a3d7bd1a"><td class="memTemplItemLeft" align="right" valign="top">Optional&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga8cc6a885a16bffa80423f7b8a3d7bd1a">makeOptional</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ga8cc6a885a16bffa80423f7b8a3d7bd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emplaces an object directly inside the <a class="el" href="classaurora_1_1_optional.html" title="Represents optional values. ">aurora::Optional</a> object.  <a href="#ga8cc6a885a16bffa80423f7b8a3d7bd1a">More...</a><br /></td></tr>
<tr class="separator:ga8cc6a885a16bffa80423f7b8a3d7bd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3d7a9da764f6068ef231bf0b45667b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf3d7a9da764f6068ef231bf0b45667b6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#gaf3d7a9da764f6068ef231bf0b45667b6">operator==</a> (const Optional&lt; T &gt; &amp;lhs, const Optional&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf3d7a9da764f6068ef231bf0b45667b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality comparison.  <a href="#gaf3d7a9da764f6068ef231bf0b45667b6">More...</a><br /></td></tr>
<tr class="separator:gaf3d7a9da764f6068ef231bf0b45667b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77529d608302836ca89fb8849ae4dcd6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga77529d608302836ca89fb8849ae4dcd6"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga77529d608302836ca89fb8849ae4dcd6">operator!=</a> (const Optional&lt; T &gt; &amp;lhs, const Optional&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga77529d608302836ca89fb8849ae4dcd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality comparison.  <a href="#ga77529d608302836ca89fb8849ae4dcd6">More...</a><br /></td></tr>
<tr class="separator:ga77529d608302836ca89fb8849ae4dcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6607c69c897d100851f960c70a57acac"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6607c69c897d100851f960c70a57acac"></a>
template&lt;typename T , std::size_t Size, std::size_t Align&gt; </td></tr>
<tr class="memitem:ga6607c69c897d100851f960c70a57acac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tools.html#ga6607c69c897d100851f960c70a57acac">swap</a> (PImpl&lt; T, Size, Align &gt; &amp;lhs, PImpl&lt; T, Size, Align &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga6607c69c897d100851f960c70a57acac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two implementation objects. <br /></td></tr>
<tr class="separator:ga6607c69c897d100851f960c70a57acac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga06858a48f53bd24ab8baa41256d3bbab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga06858a48f53bd24ab8baa41256d3bbab"></a>
const SafeBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#ga06858a48f53bd24ab8baa41256d3bbab">aurora::SafeBoolTrue</a></td></tr>
<tr class="memdesc:ga06858a48f53bd24ab8baa41256d3bbab"><td class="mdescLeft">&#160;</td><td class="mdescRight">SafeBool literal, evaluates to true. <br /></td></tr>
<tr class="separator:ga06858a48f53bd24ab8baa41256d3bbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc9f1e0c07f8b15a62bb8ec9df370513"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadc9f1e0c07f8b15a62bb8ec9df370513"></a>
const SafeBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___tools.html#gadc9f1e0c07f8b15a62bb8ec9df370513">aurora::SafeBoolFalse</a></td></tr>
<tr class="memdesc:gadc9f1e0c07f8b15a62bb8ec9df370513"><td class="mdescLeft">&#160;</td><td class="mdescRight">SafeBool literal, evaluates to false. <br /></td></tr>
<tr class="separator:gadc9f1e0c07f8b15a62bb8ec9df370513"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>C++ utility and idioms, such as noncopyable base classes, foreach macros or safe bool idiom. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaa96508df6697039877c7508f2c98a539"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_FOREACH</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">declaration, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">container&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Macro that emulates C++11 range-based for loop. </p>
<p>Code example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;std::vector&lt;int&gt; v = createVector();</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AURORA_FOREACH(int&amp; i, v)</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;{</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    i += 2;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;}</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gad856776103175a93968221ee22469bf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_GLOBAL_SWAP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Class</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="group___smart_ptr.html#gad0d298909455fba47dc3b20f856f441b">swap</a>(Class&amp; lhs, Class&amp; rhs)    \</div>
<div class="line">{                                           \</div>
<div class="line">    lhs.swap(rhs);                          \</div>
<div class="line">}</div>
<div class="ttc" id="group___smart_ptr_html_gad0d298909455fba47dc3b20f856f441b"><div class="ttname"><a href="group___smart_ptr.html#gad0d298909455fba47dc3b20f856f441b">aurora::CopiedPtr::swap</a></div><div class="ttdeci">void swap(CopiedPtr&lt; T &gt; &amp;lhs, CopiedPtr&lt; T &gt; &amp;rhs)</div><div class="ttdoc">Swaps the contents of two CopiedPtr instances. </div><div class="ttdef"><b>Definition:</b> CopiedPtr.hpp:312</div></div>
</div><!-- fragment -->
<p>Macro to implement a global overload of <code>swap(lhs, rhs)</code> to allow argument-dependent lookup. </p>
<p>Accesses the member function <code>void Class::swap(Class&amp;)</code>. </p>

</div>
</div>
<a class="anchor" id="ga6138d31f634740595bd3165302b261d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_NAMED_TUPLE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TupleName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">typeVarPairs&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Named tuple definition. </p>
<p>Defines a struct type with a specified list of public members and a corresponding constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TupleName</td><td>Name of the struct </td></tr>
    <tr><td class="paramname">typeVarPairs</td><td>Parenthesized sequence of (Type, variable) pairs, such as ((int, i), (double, d))</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Defines a named tuple called Index2D with two members x and y of type std::size_t</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AURORA_NAMED_TUPLE(Index2D,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;(</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    (std::size_t,  x),</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    (std::size_t,  y)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;))</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;// Defines a named tuple called Tile with members index (of type Index2D) and visible (of type bool)</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;AURORA_NAMED_TUPLE(Tile,</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;(</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;    (Index2D,      index),</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    (bool,         visible)</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;))</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;// Create tuple object using constructor</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;Tile tile(Index2D(2, 3), true);</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;// Access members</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;tile.index.x = 40;</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;if (tile.visible)</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;    ...</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gabfe2358c9b73b857434abe40a863eb61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_NAMED_TUPLE_EXT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TupleName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">typeVarPairs, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">extensions&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Named tuple definition with extended functionality. </p>
<p>Defines a struct type with a specified list of public members and a corresponding constructor. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">TupleName</td><td>Name of the struct </td></tr>
    <tr><td class="paramname">typeVarPairs</td><td>Parenthesized sequence of (Type, variable) pairs, such as ((int, i), (double, d)) </td></tr>
    <tr><td class="paramname">extensions</td><td>Parenthesized sequence of extensions, such as (AURORA_NT_EQUAL, AURORA_NT_LESS). Possible arguments are all macros that begin with AURORA_NT_.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;// Defines a named tuple called Index2D, with a default constructor and operator&lt;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;AURORA_NAMED_TUPLE_EXT(Index2D,</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;(</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    (std::size_t,  x),</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    (std::size_t,  y)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;),</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;(AURORA_NT_DEFAULT_CTOR, AURORA_NT_LESS))</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;// Use constructor with arguments and default constructor</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;Index2D i(2, 1);</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;Index2D j;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;// Access members</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;j.x = 1;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;j.y = 3;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;// Use operator&lt; for key in map</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;std::map&lt;Index2D, Tile&gt; tileMap;</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ga73d7061fe6c18f98be007687ab80b26c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_NT_DEFAULT_CTOR</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TupleName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">typeVarPairs&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor for named tuples. </p>
<p>Supplies the named tuple with a default constructor calls each members' default constructor. Do not invoke this macro directly. It is passed to <a class="el" href="group___tools.html#gabfe2358c9b73b857434abe40a863eb61">AURORA_NAMED_TUPLE_EXT</a>. </p>

</div>
</div>
<a class="anchor" id="ga3eabdd0b9a6496bb8f00c8d073e6cd79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_NT_EQUAL</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TupleName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">typeVarPairs&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator == for named tuples. </p>
<p>Supplies the named tuple with an operator== in the surrounding namespace, which compares member-wise. Do not invoke this macro directly. It is passed to <a class="el" href="group___tools.html#gabfe2358c9b73b857434abe40a863eb61">AURORA_NAMED_TUPLE_EXT</a>. </p>

</div>
</div>
<a class="anchor" id="ga9e0d50fb1008002ba6dac10f3be167fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_NT_HASHER</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TupleName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">typeVarPairs&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Hash functor for named tuples. </p>
<p>Supplies the named tuple with a member typedef <code>Hasher</code> inside the tuple class. Do not invoke this macro directly. It is passed to <a class="el" href="group___tools.html#gabfe2358c9b73b857434abe40a863eb61">AURORA_NAMED_TUPLE_EXT</a>. </p>

</div>
</div>
<a class="anchor" id="gac03a3f07e3e9703a2932ad5396dbee94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define AURORA_NT_LESS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">TupleName, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">typeVarPairs&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Comparison operator &lt; for named tuples. </p>
<p>Supplies the named tuple with an operator&lt; in the surrounding namespace, which compares lexicographically. Do not invoke this macro directly. It is passed to <a class="el" href="group___tools.html#gabfe2358c9b73b857434abe40a863eb61">AURORA_NAMED_TUPLE_EXT</a>. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gad8dc7698168e82026e52320b83d647fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void adlSwap </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>swap() function with argument-dependent lookup </p>
<p>Chooses the best overload of <code>swap(lhs, rhs)</code> with argument-dependent lookup. If none is found, <code>std::swap()</code> will be called. </p>

</div>
</div>
<a class="anchor" id="gae2356b9cf59292cfc68ba2bb06127394"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator aurora::binarySearch </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Binary search for value in iterator range. </p>
<p>Performs a binary search with a useful return value, in contrast to std::binary_search(). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first,last</td><td>Iterator range </td></tr>
    <tr><td class="paramname">value</td><td>Value to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Either iterator to first found element, or end-iterator of sequence </dd></dl>

</div>
</div>
<a class="anchor" id="gae43736a4dea0944c8b0c734775a7e95c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Queue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aurora::clearQueue </td>
          <td>(</td>
          <td class="paramtype">Queue &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear std::queue. </p>
<p>Calls <a class="el" href="group___tools.html#ga759df97003e1beb0b9a2501805e0eca6" title="Pop from queue with return value. ">pop()</a> repeatedly until the queue is empty. </p>

</div>
</div>
<a class="anchor" id="ga8aae4a4cf8c6ec37cfd54a4f2dc4aaf6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">To aurora::downcast </td>
          <td>(</td>
          <td class="paramtype">From &amp;&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe polymorphic downcast for references. </p>
<p>Can be used in place of a static_cast from a base class to a derived class &ndash; that is, you expect the downcast to succeed. In debug mode, types are checked at runtime using dynamic_cast. In release mode (with the NDBEBUG macro defined), a static_cast at full speed is used. </p>

</div>
</div>
<a class="anchor" id="ga3e8dbf1c8d81ee5a15a815c3197c36f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">To aurora::downcast </td>
          <td>(</td>
          <td class="paramtype">From *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe polymorphic downcast for pointers. </p>
<p>Can be used in place of a static_cast from a base class to a derived class &ndash; that is, you expect the downcast to succeed. In debug mode, types are checked at runtime using dynamic_cast. In release mode (with the NDBEBUG macro defined), a static_cast at full speed is used. </p>

</div>
</div>
<a class="anchor" id="gae76851fa9c764a9a6b2ba121c600b703"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool aurora::equivalent </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determines whether two values are considered equivalent in sorting. </p>
<p>Equal implies equivalent, but not vice versa. Two values are considered equivalent if neither appears before the other (w.r.t. sorting criterion, here operator&lt;) </p>

</div>
</div>
<a class="anchor" id="gadbc61ba01e3e5ca2d9165a74b328eff8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aurora::eraseUnordered </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>itr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase element using swap-and-pop_back idiom. </p>
<p>Erases the element at position <code>itr</code> by swapping it with the last element in the container and erasing the last element. This O(1) operation is particularly useful for std::vector or std::deque as long as the element order is not relevant. </p>

</div>
</div>
<a class="anchor" id="ga8cc6a885a16bffa80423f7b8a3d7bd1a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Optional&lt; T &gt; makeOptional </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emplaces an object directly inside the <a class="el" href="classaurora_1_1_optional.html" title="Represents optional values. ">aurora::Optional</a> object. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// These declarations are semantically equivalent (however different constructors can be called):</span></div>
<div class="line"><a class="code" href="classaurora_1_1_optional.html">aurora::Optional&lt;MyClass&gt;</a> opt(aurora::inplace, arg1, arg2);</div>
<div class="line"><span class="keyword">auto</span> opt = aurora::makeOptional&lt;MyClass&gt;(arg1, arg2); <span class="comment">// may invoke move constructor</span></div>
<div class="line"><a class="code" href="classaurora_1_1_optional.html">aurora::Optional&lt;MyClass&gt;</a> opt = MyClass(arg1, arg2); <span class="comment">// may invoke move or copy constructor</span></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Variable argument list, the single arguments are forwarded to T's constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structaurora_1_1_inplace_type.html" title="Tag to construct optional objects in-place. ">InplaceType</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga221d90caecf195f0613d6a91045abb8b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AssocContainer , typename Key &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">AssocContainer::mapped_type&amp; aurora::mapAt </td>
          <td>(</td>
          <td class="paramtype">AssocContainer &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value type for a specific key. </p>
<p>Assumes existence of the key, returns corresponding mapped type without inserting it. In contrast to <code>std::[unordered_]map::at()</code>, this does not throw exceptions. If the key is not available, the behavior is undefined, in favor of optimized performance. </p>

</div>
</div>
<a class="anchor" id="ga77529d608302836ca89fb8849ae4dcd6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaurora_1_1_optional.html">Optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaurora_1_1_optional.html">Optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality comparison. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group___tools.html#gaf3d7a9da764f6068ef231bf0b45667b6" title="Equality comparison. ">operator==(const Optional&lt;T&gt;&amp; lhs, const Optional&lt;T&gt;&amp; rhs)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3d7a9da764f6068ef231bf0b45667b6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classaurora_1_1_optional.html">Optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classaurora_1_1_optional.html">Optional</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality comparison. </p>
<p>Semantics: Returns true if both operands are empty, or if both are non-empty and the expression <code>*lhs == *rhs<code> returns true. </code></code></p>

</div>
</div>
<a class="anchor" id="ga759df97003e1beb0b9a2501805e0eca6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Queue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Queue::value_type aurora::pop </td>
          <td>(</td>
          <td class="paramtype">Queue &amp;&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pop from queue with return value. </p>
<p>Combines std::queue's pop() and front() operations. </p>

</div>
</div>
<a class="anchor" id="ga9cf7ec4903809d8f39ab30abdb0f0988"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Value &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aurora::remove </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase-remove idiom. </p>
<p>Removes value <code>v</code> from sequential container <code>c</code> (std::vector or std::deque) </p>

</div>
</div>
<a class="anchor" id="gabb66a2469b6e1cad65b955d269fbb4d1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void aurora::removeIf </td>
          <td>(</td>
          <td class="paramtype">Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erase-remove-if idiom. </p>
<p>Removes value <code>v</code> from sequential container <code>c</code> (std::vector or std::deque) </p>

</div>
</div>
<a class="anchor" id="ga47a267cff5ab30391db8237a63a58dd3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::type_index aurora::typeIndex </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>reference</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe typeid operator for references. </p>
<p>The C++ typeid operator can easily be used incorrectly in RTTI scenarios, leading to tedious bugs at runtime:</p><ul>
<li>The operand is a value instead of a reference.</li>
<li>The operand is a pointer which was not dereferenced.</li>
<li>The operand is an incomplete type. The compiler has no knowledge about the polymorphic class hierarchy at this point.</li>
<li>The class is not polymorphic. This can happen when a destructor was not declared virtual.</li>
</ul>
<p>This implementation makes sure that the above-mentioned cases do not occur. Type verification happens at compile time, so there is no performance overhead in using this function. This function is specifically designed for the use of RTTI in polymorphic class hierarchies, it cannot be used in other scenarios (e.g. printing arbitrary type names for debugging).</p>
<p>Usage: </p><div class="fragment"><div class="line">Base&amp; baseRef = ...;</div>
<div class="line">std::type_index t = <a class="code" href="group___tools.html#ga47a267cff5ab30391db8237a63a58dd3">aurora::typeIndex</a>(baseRef);</div>
</div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="gaed775a738be90f56656000c5157196f8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::type_index aurora::typeIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe typeid operator for types. </p>
<p>Same as <code>typeIndex(T&amp; reference)</code>, but for types.</p>
<p>Usage: </p><div class="fragment"><div class="line">std::type_index t = aurora::typeIndex&lt;Base&gt;();</div>
</div><!-- fragment --> 
</div>
</div>
</div><!-- contents -->

<!--hr class="footer" /-->
<div id="footer">
  Copyright (c) Jan Haller 2011-2016
</div>
<!--
<address class="footer"><small>
Generated on Sun Jan 17 2016 23:02:44 for Thor by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10</small></address>
-->
</body>
</html>
