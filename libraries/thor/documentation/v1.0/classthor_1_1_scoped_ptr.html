<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>thor::ScopedPtr&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!--<script type="text/javascript" src="$relpath/search.js"></script>-->
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body> <!-- onload='searchBox.OnSelectItem(0);'> -->


<div id="header1"><img src="../../../../bromeon.png" alt="Bromeon"/>
</div>
<div class="sidebar">
  <p><a href="../../../../index.html">Home</a></p>
  <p><a href="../../../../libraries/index.html">C++ Libraries</a></p>
  <div class="sb-sub">
    <p><a href="../../../thor/index.html">Thor</a></p>
    <div class="sb-sub2">
      <div class="sb-cur">
        <p><a href="../../documentation.html">Documentation</a></p>
      </div>
      <p><a href="../../download.html">Download</a></p>
      <p><a href="../../tutorials.html">Tutorials</a></p>
    </div>
    <p><a href="../../../aurora/index.html">Aurora</a></p>
  </div>
  <p><a href="../../../../games/index.html">Games</a></p>
  <p><a href="../../../../contact.html">Contact</a></p>
</div>

<!--
<div id="header"><img src="Bromeon.png" alt="Bromeon" />
</div>
<div id="sidebar">
  <p><a href="index.html">Home</a></p>
  <p><a href="thor.html">Thor C++ Library</a></p>
  <p><a href="doc/index.html">Documentation</a></p>
<p>Tutorials</p>
<p>Downloads</p>
</div>
-->

<div id="top"><!-- do not remove this div! -->
<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>thor</b>      </li>
      <li class="navelem"><a class="el" href="classthor_1_1_scoped_ptr.html">ScopedPtr</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#related">Related Functions</a>  </div>
  <div class="headertitle">
<div class="title">thor::ScopedPtr&lt; T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___smart_ptr.html">SmartPtr</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Noncopyable smart pointer that destroys objects going out of scope.  
 <a href="classthor_1_1_scoped_ptr.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for thor::ScopedPtr&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classthor_1_1_scoped_ptr__inherit__graph.png" border="0" usemap="#thor_1_1_scoped_ptr_3_01_t_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="thor_1_1_scoped_ptr_3_01_t_01_4_inherit__map" id="thor_1_1_scoped_ptr_3_01_t_01_4_inherit__map">
<area shape="rect" id="node2" href="classthor_1_1_non_copyable.html" title="Non&#45;copyable base class." alt="" coords="13,5,141,35"/>
</map>
</div>

<p><a href="classthor_1_1_scoped_ptr-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9c70a71f4d053efc29b88913a95c7dc9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#a9c70a71f4d053efc29b88913a95c7dc9">ScopedPtr</a> ()</td></tr>
<tr class="memdesc:a9c70a71f4d053efc29b88913a95c7dc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a9c70a71f4d053efc29b88913a95c7dc9"></a><br/></td></tr>
<tr class="memitem:af31962498e51dfe0fb6fb62cfd2951fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#af31962498e51dfe0fb6fb62cfd2951fb">ScopedPtr</a> (T *pointer)</td></tr>
<tr class="memdesc:af31962498e51dfe0fb6fb62cfd2951fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor from raw pointer.  <a href="#af31962498e51dfe0fb6fb62cfd2951fb"></a><br/></td></tr>
<tr class="memitem:ae5d6a365d98388ac2e7aca7e5b6f59be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#ae5d6a365d98388ac2e7aca7e5b6f59be">~ScopedPtr</a> ()</td></tr>
<tr class="memdesc:ae5d6a365d98388ac2e7aca7e5b6f59be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#ae5d6a365d98388ac2e7aca7e5b6f59be"></a><br/></td></tr>
<tr class="memitem:a02eca72693331f51224e7cfbc3921d26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#a02eca72693331f51224e7cfbc3921d26">Swap</a> (<a class="el" href="classthor_1_1_scoped_ptr.html">ScopedPtr</a> &amp;other)</td></tr>
<tr class="memdesc:a02eca72693331f51224e7cfbc3921d26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the pointers of <em>*this</em> and <em>other</em>.  <a href="#a02eca72693331f51224e7cfbc3921d26"></a><br/></td></tr>
<tr class="memitem:a6f4822e96b30ce499576404866294de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#a6f4822e96b30ce499576404866294de8">Reset</a> ()</td></tr>
<tr class="memdesc:a6f4822e96b30ce499576404866294de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the internal pointer to <em>NULL</em>.  <a href="#a6f4822e96b30ce499576404866294de8"></a><br/></td></tr>
<tr class="memitem:a90da80925894dfb98ff4adb3a7155913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#a90da80925894dfb98ff4adb3a7155913">Reset</a> (T *pointer)</td></tr>
<tr class="memdesc:a90da80925894dfb98ff4adb3a7155913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the internal pointer to the passed value.  <a href="#a90da80925894dfb98ff4adb3a7155913"></a><br/></td></tr>
<tr class="memitem:adf8f74ad989bcc39658b0929527e4b3a"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#adf8f74ad989bcc39658b0929527e4b3a">Release</a> ()</td></tr>
<tr class="memdesc:adf8f74ad989bcc39658b0929527e4b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers ownership of the held object to the caller.  <a href="#adf8f74ad989bcc39658b0929527e4b3a"></a><br/></td></tr>
<tr class="memitem:ad0852e8ac445c441626586a1849fb84a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#ad0852e8ac445c441626586a1849fb84a">operator SafeBool</a> () const </td></tr>
<tr class="memdesc:ad0852e8ac445c441626586a1849fb84a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the pointer currently points to <em>NULL</em>.  <a href="#ad0852e8ac445c441626586a1849fb84a"></a><br/></td></tr>
<tr class="memitem:a368e2f65e2bcb19f1b2f91246ab47cd1"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#a368e2f65e2bcb19f1b2f91246ab47cd1">operator*</a> () const </td></tr>
<tr class="memdesc:a368e2f65e2bcb19f1b2f91246ab47cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the pointer.  <a href="#a368e2f65e2bcb19f1b2f91246ab47cd1"></a><br/></td></tr>
<tr class="memitem:aed0db45fb916f61f2e258b9ed4fcc3cd"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#aed0db45fb916f61f2e258b9ed4fcc3cd">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:aed0db45fb916f61f2e258b9ed4fcc3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dereferences the pointer for member access.  <a href="#aed0db45fb916f61f2e258b9ed4fcc3cd"></a><br/></td></tr>
<tr class="memitem:a27a55f4ea82a3bb64c046b8caf7266f4"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_scoped_ptr.html#a27a55f4ea82a3bb64c046b8caf7266f4">Get</a> () const </td></tr>
<tr class="memdesc:a27a55f4ea82a3bb64c046b8caf7266f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permits access to the internal pointer. Designed for rare use.  <a href="#a27a55f4ea82a3bb64c046b8caf7266f4"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="related"></a>
Related Functions</h2></td></tr>
<tr class="memitem:ga4c43517cf2b4a16431eb9969729dfe26"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4c43517cf2b4a16431eb9969729dfe26"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4c43517cf2b4a16431eb9969729dfe26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___smart_ptr.html#ga4c43517cf2b4a16431eb9969729dfe26">thor::swap</a> (<a class="el" href="classthor_1_1_scoped_ptr.html">ScopedPtr</a>&lt; T &gt; &amp;lhs, <a class="el" href="classthor_1_1_scoped_ptr.html">ScopedPtr</a>&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga4c43517cf2b4a16431eb9969729dfe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two ScopedPtr&lt;T&gt; instances. <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br/>
class thor::ScopedPtr&lt; T &gt;</h3>

<p>Noncopyable smart pointer that destroys objects going out of scope. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">T</td><td>The pointee type</td></tr>
  </table>
  </dd>
</dl>
<p>Copy constructor and assignment operators can't be called using this smart pointer. This implementation is useful for local RAII smart pointers that don't need to share or copy ownership and that prevent you from accidentally doing it. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9c70a71f4d053efc29b88913a95c7dc9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::<a class="el" href="classthor_1_1_scoped_ptr.html">ScopedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor. </p>
<p>Initializes the smart pointer with a null pointer. This operation doesn't require T to be defined. </p>

</div>
</div>
<a class="anchor" id="af31962498e51dfe0fb6fb62cfd2951fb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::<a class="el" href="classthor_1_1_scoped_ptr.html">ScopedPtr</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor from raw pointer. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>The initial pointer value, either pointing to an object allocated by the <em>new</em> operator or to <em>NULL</em>. If the dynamic type of <em>pointer</em> is a class derived from T, then T must have a virtual destructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5d6a365d98388ac2e7aca7e5b6f59be"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::~<a class="el" href="classthor_1_1_scoped_ptr.html">ScopedPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Destroys the object and deallocates the corresponding memory. For null pointers, nothing happens. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a27a55f4ea82a3bb64c046b8caf7266f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::<a class="el" href="classthor_1_1_scoped_ptr.html#a27a55f4ea82a3bb64c046b8caf7266f4">Get</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Permits access to the internal pointer. Designed for rare use. </p>
<dl class="section return"><dt>Returns:</dt><dd>Internally used pointer, use it wisely not to upset the <a class="el" href="classthor_1_1_scoped_ptr.html" title="Noncopyable smart pointer that destroys objects going out of scope.">ScopedPtr</a>'s memory management. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0852e8ac445c441626586a1849fb84a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::operator SafeBool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks whether the pointer currently points to <em>NULL</em>. </p>
<p>This allows you to write statements of the form <em>if(ptr)</em> or <em>if(!ptr)</em> in a type-safe way (<em>ptr</em> refers to a smart-pointer instance). The actual return type is implementation-defined. </p>
<dl class="section return"><dt>Returns:</dt><dd>bool-like value that behaves in conditional expressions like true, if the pointer is valid; and like false, if it points to <em>NULL</em>. </dd></dl>

</div>
</div>
<a class="anchor" id="a368e2f65e2bcb19f1b2f91246ab47cd1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dereferences the pointer. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>The smart pointer must be non-empty. </dd></dl>

</div>
</div>
<a class="anchor" id="aed0db45fb916f61f2e258b9ed4fcc3cd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dereferences the pointer for member access. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>The smart pointer must be non-empty. </dd></dl>

</div>
</div>
<a class="anchor" id="adf8f74ad989bcc39658b0929527e4b3a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::<a class="el" href="classthor_1_1_scoped_ptr.html#adf8f74ad989bcc39658b0929527e4b3a">Release</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfers ownership of the held object to the caller. </p>
<p>Upon invoking <a class="el" href="classthor_1_1_scoped_ptr.html#adf8f74ad989bcc39658b0929527e4b3a" title="Transfers ownership of the held object to the caller.">Release()</a>, the caller becomes responsible for the memory management of the returned pointer. This instance points to null after the operation. </p>

</div>
</div>
<a class="anchor" id="a6f4822e96b30ce499576404866294de8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::<a class="el" href="classthor_1_1_scoped_ptr.html#a6f4822e96b30ce499576404866294de8">Reset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the internal pointer to <em>NULL</em>. </p>
<p>Destroys the current object, and sets the internal pointer to <em>NULL</em>. This operation doesn't require T to be defined. </p>

</div>
</div>
<a class="anchor" id="a90da80925894dfb98ff4adb3a7155913"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::<a class="el" href="classthor_1_1_scoped_ptr.html#a6f4822e96b30ce499576404866294de8">Reset</a> </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resets the internal pointer to the passed value. </p>
<p>Destroys the current object, and re-assigns the pointer. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">pointer</td><td>The new pointer value, either pointing to an object allocated by the <em>new</em> operator or to <em>NULL</em>. If the dynamic type of <em>pointer</em> is a class derived from T, then T must have a virtual destructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02eca72693331f51224e7cfbc3921d26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthor_1_1_scoped_ptr.html">thor::ScopedPtr</a>&lt; T &gt;::<a class="el" href="classthor_1_1_scoped_ptr.html#a02eca72693331f51224e7cfbc3921d26">Swap</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classthor_1_1_scoped_ptr.html">ScopedPtr</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swaps the pointers of <em>*this</em> and <em>other</em>. </p>
<p><a class="el" href="classthor_1_1_scoped_ptr.html#a02eca72693331f51224e7cfbc3921d26" title="Swaps the pointers of *this and other.">Swap()</a> doesn't operate on the object itself, only on the pointer. T may be incomplete at invocation. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>SmartPtr/<a class="el" href="_scoped_ptr_8hpp_source.html">ScopedPtr.hpp</a></li>
</ul>
</div><!-- contents -->

<!--hr class="footer" /-->
<div id="footer">
  Copyright (c) Jan Haller 2011-2016
</div>
<!--
<address class="footer"><small>
Generated on Sat Jun 16 2012 16:43:54 for Thor by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0</small></address>
-->
</body>
</html>
