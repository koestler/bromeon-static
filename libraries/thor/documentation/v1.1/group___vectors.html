<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Vectors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!--<script type="text/javascript" src="$relpath/search.js"></script>-->
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body> <!-- onload='searchBox.OnSelectItem(0);'> -->


<div id="header1"><img src="../../../../bromeon.png" alt="Bromeon"/>
</div>
<div class="sidebar">
  <p><a href="../../../../index.html">Home</a></p>
  <p><a href="../../../../libraries/index.html">C++ Libraries</a></p>
  <div class="sb-sub">
    <p><a href="../../../thor/index.html">Thor</a></p>
    <div class="sb-sub2">
      <div class="sb-cur">
        <p><a href="../../documentation.html">Documentation</a></p>
      </div>
      <p><a href="../../download.html">Download</a></p>
      <p><a href="../../tutorials.html">Tutorials</a></p>
    </div>
    <p><a href="../../../aurora/index.html">Aurora</a></p>
  </div>
  <p><a href="../../../../games/index.html">Games</a></p>
  <p><a href="../../../../contact.html">Contact</a></p>
</div>

<!--
<div id="header"><img src="Bromeon.png" alt="Bromeon" />
</div>
<div id="sidebar">
  <p><a href="index.html">Home</a></p>
  <p><a href="thor.html">Thor C++ Library</a></p>
  <p><a href="doc/index.html">Documentation</a></p>
<p>Tutorials</p>
<p>Downloads</p>
</div>
-->

<div id="top"><!-- do not remove this div! -->
<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Vectors</div>  </div>
</div><!--header-->
<div class="contents">

<p>A lot of operations based on sf::Vector2 and sf::Vector3. For specific overview, see <a class="el" href="_vector_algebra2_d_8hpp.html" title="Algebraic operations on two-dimensional vectors (dot product, vector length and angles, ...)">VectorAlgebra2D.hpp</a> and <a class="el" href="_vector_algebra3_d_8hpp.html" title="Algebraic operations on three-dimensional vectors (dot and cross product, vector length and angles...">VectorAlgebra3D.hpp</a>.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structthor_1_1_polar_vector2.html">thor::PolarVector2&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector in polar coordinate system.  <a href="structthor_1_1_polar_vector2.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1878dd06373b0fe78430467901a0d3f9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1878dd06373b0fe78430467901a0d3f9"></a>
typedef PolarVector2&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga1878dd06373b0fe78430467901a0d3f9">thor::PolarVector2f</a></td></tr>
<tr class="memdesc:ga1878dd06373b0fe78430467901a0d3f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type definition for float polar vectors. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad9881856439c3c1973c373900cc9ea57"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad9881856439c3c1973c373900cc9ea57"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gad9881856439c3c1973c373900cc9ea57"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gad9881856439c3c1973c373900cc9ea57">thor::Length</a> (const sf::Vector2&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:gad9881856439c3c1973c373900cc9ea57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the 2D vector. <br/></td></tr>
<tr class="memitem:ga1012c58d15fbdbb288516f31bfc726b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga1012c58d15fbdbb288516f31bfc726b5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga1012c58d15fbdbb288516f31bfc726b5">thor::SquaredLength</a> (const sf::Vector2&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga1012c58d15fbdbb288516f31bfc726b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of <em>vector's</em> length.  <a href="#ga1012c58d15fbdbb288516f31bfc726b5"></a><br/></td></tr>
<tr class="memitem:ga53d4235a898dae45a95151917492faac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga53d4235a898dae45a95151917492faac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga53d4235a898dae45a95151917492faac">thor::SetLength</a> (sf::Vector2&lt; T &gt; &amp;vector, T newLength)</td></tr>
<tr class="memdesc:ga53d4235a898dae45a95151917492faac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adapts <em>vector</em> so that its length is |<em>newLength|</em> after this operation.  <a href="#ga53d4235a898dae45a95151917492faac"></a><br/></td></tr>
<tr class="memitem:gaf3b94d5a7158c94964f0bbb525cac15c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf3b94d5a7158c94964f0bbb525cac15c"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector2&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gaf3b94d5a7158c94964f0bbb525cac15c">thor::UnitVector</a> (const sf::Vector2&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:gaf3b94d5a7158c94964f0bbb525cac15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with same direction as the argument, but with length 1.  <a href="#gaf3b94d5a7158c94964f0bbb525cac15c"></a><br/></td></tr>
<tr class="memitem:ga5e0a54771f8f2cc23cf06be509a3d54b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5e0a54771f8f2cc23cf06be509a3d54b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga5e0a54771f8f2cc23cf06be509a3d54b">thor::PolarAngle</a> (const sf::Vector2&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga5e0a54771f8f2cc23cf06be509a3d54b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the polar angle.  <a href="#ga5e0a54771f8f2cc23cf06be509a3d54b"></a><br/></td></tr>
<tr class="memitem:ga5d1daa4962e7a4a429c20440163e0896"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga5d1daa4962e7a4a429c20440163e0896"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga5d1daa4962e7a4a429c20440163e0896">thor::SetPolarAngle</a> (sf::Vector2&lt; T &gt; &amp;vector, T newAngle)</td></tr>
<tr class="memdesc:ga5d1daa4962e7a4a429c20440163e0896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the polar angle of the specified vector.  <a href="#ga5d1daa4962e7a4a429c20440163e0896"></a><br/></td></tr>
<tr class="memitem:gab082b7ada7dcce3f6bf563f11dc63e51"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab082b7ada7dcce3f6bf563f11dc63e51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gab082b7ada7dcce3f6bf563f11dc63e51">thor::Rotate</a> (sf::Vector2&lt; T &gt; &amp;vector, T angle)</td></tr>
<tr class="memdesc:gab082b7ada7dcce3f6bf563f11dc63e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates the vector by the given angle (in degrees).  <a href="#gab082b7ada7dcce3f6bf563f11dc63e51"></a><br/></td></tr>
<tr class="memitem:ga3b820024c1a5d34aa69975fc0f3bb654"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3b820024c1a5d34aa69975fc0f3bb654"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector2&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga3b820024c1a5d34aa69975fc0f3bb654">thor::RotatedVector</a> (const sf::Vector2&lt; T &gt; &amp;vector, T angle)</td></tr>
<tr class="memdesc:ga3b820024c1a5d34aa69975fc0f3bb654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the vector, rotated by <em>angle</em> degrees.  <a href="#ga3b820024c1a5d34aa69975fc0f3bb654"></a><br/></td></tr>
<tr class="memitem:gadf28a44d32c67890cffbdb01de961260"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gadf28a44d32c67890cffbdb01de961260"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector2&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gadf28a44d32c67890cffbdb01de961260">thor::PerpendicularVector</a> (const sf::Vector2&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:gadf28a44d32c67890cffbdb01de961260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a perpendicular vector.  <a href="#gadf28a44d32c67890cffbdb01de961260"></a><br/></td></tr>
<tr class="memitem:gaf13f6e526241bed27d8d1c45585cc655"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaf13f6e526241bed27d8d1c45585cc655"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gaf13f6e526241bed27d8d1c45585cc655">thor::Angle</a> (const sf::Vector2&lt; T &gt; &amp;lhs, const sf::Vector2&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gaf13f6e526241bed27d8d1c45585cc655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the signed angle from <em>lhs</em> to <em>rhs</em>.  <a href="#gaf13f6e526241bed27d8d1c45585cc655"></a><br/></td></tr>
<tr class="memitem:ga15260cf214c245cbc0d888158404a406"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga15260cf214c245cbc0d888158404a406"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga15260cf214c245cbc0d888158404a406"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga15260cf214c245cbc0d888158404a406">thor::DotProduct</a> (const sf::Vector2&lt; T &gt; &amp;lhs, const sf::Vector2&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga15260cf214c245cbc0d888158404a406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product of two 2D vectors. <br/></td></tr>
<tr class="memitem:gae9ba4d21139dbb6f2eb548e024c87fd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae9ba4d21139dbb6f2eb548e024c87fd5"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector3&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gae9ba4d21139dbb6f2eb548e024c87fd5">thor::CrossProduct</a> (const sf::Vector2&lt; T &gt; &amp;lhs, const sf::Vector2&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gae9ba4d21139dbb6f2eb548e024c87fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cross product of two 2D vectors.  <a href="#gae9ba4d21139dbb6f2eb548e024c87fd5"></a><br/></td></tr>
<tr class="memitem:ga79bd691e693487e48ca53e3a8cf4c92c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga79bd691e693487e48ca53e3a8cf4c92c"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector2&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga79bd691e693487e48ca53e3a8cf4c92c">thor::ComponentwiseProduct</a> (const sf::Vector2&lt; T &gt; &amp;lhs, const sf::Vector2&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga79bd691e693487e48ca53e3a8cf4c92c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise product of <em>lhs</em> and <em>rhs</em>.  <a href="#ga79bd691e693487e48ca53e3a8cf4c92c"></a><br/></td></tr>
<tr class="memitem:gab936ea34c2e8b925100024465abab318"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gab936ea34c2e8b925100024465abab318"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector2&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gab936ea34c2e8b925100024465abab318">thor::ComponentwiseQuotient</a> (const sf::Vector2&lt; T &gt; &amp;lhs, const sf::Vector2&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gab936ea34c2e8b925100024465abab318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise quotient of <em>lhs</em> and <em>rhs</em>.  <a href="#gab936ea34c2e8b925100024465abab318"></a><br/></td></tr>
<tr class="memitem:gaaefdf3364dfc5be29edbdbb6546f0d69"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaaefdf3364dfc5be29edbdbb6546f0d69"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaaefdf3364dfc5be29edbdbb6546f0d69"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gaaefdf3364dfc5be29edbdbb6546f0d69">thor::Length</a> (const sf::Vector3&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:gaaefdf3364dfc5be29edbdbb6546f0d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the 3D vector. <br/></td></tr>
<tr class="memitem:gaba5e60f43087543f22f8e8a3d5ba033a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaba5e60f43087543f22f8e8a3d5ba033a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gaba5e60f43087543f22f8e8a3d5ba033a">thor::SquaredLength</a> (const sf::Vector3&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:gaba5e60f43087543f22f8e8a3d5ba033a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the square of <em>vector's</em> length.  <a href="#gaba5e60f43087543f22f8e8a3d5ba033a"></a><br/></td></tr>
<tr class="memitem:ga834f9b0351b354227928082828360131"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga834f9b0351b354227928082828360131"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector3&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga834f9b0351b354227928082828360131">thor::UnitVector</a> (const sf::Vector3&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga834f9b0351b354227928082828360131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector with same direction as the argument, but with length 1.  <a href="#ga834f9b0351b354227928082828360131"></a><br/></td></tr>
<tr class="memitem:ga6ea1d819a159d8905957c4d04f53e3a7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6ea1d819a159d8905957c4d04f53e3a7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga6ea1d819a159d8905957c4d04f53e3a7">thor::PolarAngle</a> (const sf::Vector3&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga6ea1d819a159d8905957c4d04f53e3a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle between the projection of <em>vector</em> onto the XY-plane and the X-axis.  <a href="#ga6ea1d819a159d8905957c4d04f53e3a7"></a><br/></td></tr>
<tr class="memitem:ga2a85bb493db8b33d636a47e98dbf1f21"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2a85bb493db8b33d636a47e98dbf1f21"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga2a85bb493db8b33d636a47e98dbf1f21">thor::ElevationAngle</a> (const sf::Vector3&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga2a85bb493db8b33d636a47e98dbf1f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elevation angle of <em>vector</em>.  <a href="#ga2a85bb493db8b33d636a47e98dbf1f21"></a><br/></td></tr>
<tr class="memitem:ga44106fb95eb587d20414cabcfcb1bb7b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga44106fb95eb587d20414cabcfcb1bb7b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga44106fb95eb587d20414cabcfcb1bb7b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga44106fb95eb587d20414cabcfcb1bb7b">thor::DotProduct</a> (const sf::Vector3&lt; T &gt; &amp;lhs, const sf::Vector3&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga44106fb95eb587d20414cabcfcb1bb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the dot product of two 3D vectors. <br/></td></tr>
<tr class="memitem:ga44775aff2f90d133fe919cddd4a52d9c"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga44775aff2f90d133fe919cddd4a52d9c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga44775aff2f90d133fe919cddd4a52d9c"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector3&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga44775aff2f90d133fe919cddd4a52d9c">thor::CrossProduct</a> (const sf::Vector3&lt; T &gt; &amp;lhs, const sf::Vector3&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga44775aff2f90d133fe919cddd4a52d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cross product of two 3D vectors. <br/></td></tr>
<tr class="memitem:gabcc6aac5116e8322b928277064347f64"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gabcc6aac5116e8322b928277064347f64"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector3&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gabcc6aac5116e8322b928277064347f64">thor::ComponentwiseProduct</a> (const sf::Vector3&lt; T &gt; &amp;lhs, const sf::Vector3&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:gabcc6aac5116e8322b928277064347f64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise product of <em>lhs</em> and <em>rhs</em>.  <a href="#gabcc6aac5116e8322b928277064347f64"></a><br/></td></tr>
<tr class="memitem:ga2fe693a8e18e2e461faf99a86eacb914"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2fe693a8e18e2e461faf99a86eacb914"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector3&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga2fe693a8e18e2e461faf99a86eacb914">thor::ComponentwiseQuotient</a> (const sf::Vector3&lt; T &gt; &amp;lhs, const sf::Vector3&lt; T &gt; &amp;rhs)</td></tr>
<tr class="memdesc:ga2fe693a8e18e2e461faf99a86eacb914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the component-wise quotient of <em>lhs</em> and <em>rhs</em>.  <a href="#ga2fe693a8e18e2e461faf99a86eacb914"></a><br/></td></tr>
<tr class="memitem:ga743696e19a40edeae967c79249141dd7"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga743696e19a40edeae967c79249141dd7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga743696e19a40edeae967c79249141dd7"><td class="memTemplItemLeft" align="right" valign="top">sf::Vector3&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga743696e19a40edeae967c79249141dd7">thor::ToVector3</a> (const sf::Vector2&lt; T &gt; &amp;vector2)</td></tr>
<tr class="memdesc:ga743696e19a40edeae967c79249141dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a 3D vector from a 2D vector by setting the Z component to zero. <br/></td></tr>
<tr class="memitem:ga21a7a2ba85660b741927722fa5ba33a3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga21a7a2ba85660b741927722fa5ba33a3"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#ga21a7a2ba85660b741927722fa5ba33a3">thor::Length</a> (const PolarVector2&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:ga21a7a2ba85660b741927722fa5ba33a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of a polar vector.  <a href="#ga21a7a2ba85660b741927722fa5ba33a3"></a><br/></td></tr>
<tr class="memitem:gaa7207e5e09fd8a27316a1e79568df4c9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa7207e5e09fd8a27316a1e79568df4c9"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___vectors.html#gaa7207e5e09fd8a27316a1e79568df4c9">thor::PolarAngle</a> (const PolarVector2&lt; T &gt; &amp;vector)</td></tr>
<tr class="memdesc:gaa7207e5e09fd8a27316a1e79568df4c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the angle of a polar vector in degrees.  <a href="#gaa7207e5e09fd8a27316a1e79568df4c9"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>A lot of operations based on sf::Vector2 and sf::Vector3. For specific overview, see <a class="el" href="_vector_algebra2_d_8hpp.html" title="Algebraic operations on two-dimensional vectors (dot product, vector length and angles, ...)">VectorAlgebra2D.hpp</a> and <a class="el" href="_vector_algebra3_d_8hpp.html" title="Algebraic operations on three-dimensional vectors (dot and cross product, vector length and angles...">VectorAlgebra3D.hpp</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf13f6e526241bed27d8d1c45585cc655"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T thor::Angle </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the signed angle from <em>lhs</em> to <em>rhs</em>. </p>
<dl class="section return"><dt>Returns:</dt><dd>Angle in degrees in the interval [-180,180]. The angle determines how much you have to turn <em>lhs</em> until it points to the same direction as <em>rhs</em>. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd>Neither <em>lhs</em> nor <em>rhs</em> is a zero vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gabcc6aac5116e8322b928277064347f64"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector3&lt;T&gt; thor::ComponentwiseProduct </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sf::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the component-wise product of <em>lhs</em> and <em>rhs</em>. </p>
<p>Computes <em>(lhs.x*rhs.x, lhs.y*rhs.y, lhs.z*rhs.z)</em>. Component-wise multiplications are mainly used for scales. </p>

</div>
</div>
<a class="anchor" id="ga79bd691e693487e48ca53e3a8cf4c92c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector2&lt;T&gt; thor::ComponentwiseProduct </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the component-wise product of <em>lhs</em> and <em>rhs</em>. </p>
<p>Computes <em>(lhs.x*rhs.x, lhs.y*rhs.y)</em>. Component-wise multiplications are mainly used for scales. </p>

</div>
</div>
<a class="anchor" id="ga2fe693a8e18e2e461faf99a86eacb914"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector3&lt;T&gt; thor::ComponentwiseQuotient </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sf::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the component-wise quotient of <em>lhs</em> and <em>rhs</em>. </p>
<p>Computes <em>(lhs.x/rhs.x, lhs.y/rhs.y, lhs.z/rhs.z)</em>. Component-wise divisions are mainly used for scales. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>Neither component of <em>rhs</em> is zero. </dd></dl>

</div>
</div>
<a class="anchor" id="gab936ea34c2e8b925100024465abab318"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector2&lt;T&gt; thor::ComponentwiseQuotient </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the component-wise quotient of <em>lhs</em> and <em>rhs</em>. </p>
<p>Computes <em>(lhs.x/rhs.x, lhs.y/rhs.y)</em>. Component-wise divisions are mainly used for scales. </p>
<dl class="section pre"><dt>Precondition:</dt><dd>Neither component of <em>rhs</em> is zero. </dd></dl>

</div>
</div>
<a class="anchor" id="gae9ba4d21139dbb6f2eb548e024c87fd5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector3&lt;T&gt; thor::CrossProduct </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the cross product of two 2D vectors. </p>
<p>The behavior is equivalent to the crossproduct of two 3D vectors with the Z component being zero. The result's X and Y components are always 0. </p>

</div>
</div>
<a class="anchor" id="ga2a85bb493db8b33d636a47e98dbf1f21"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T thor::ElevationAngle </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the elevation angle of <em>vector</em>. </p>
<p>The elevation angle is the angle between the vector and the XY-plane. It has the same sign as <em>vector.z</em>. </p>
<dl class="section return"><dt>Returns:</dt><dd>Elevation angle in degrees in the interval [-90,90]. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd><em>vector</em> is no zero vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ga21a7a2ba85660b741927722fa5ba33a3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="group___vectors.html#ga21a7a2ba85660b741927722fa5ba33a3">Length</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structthor_1_1_polar_vector2.html">PolarVector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the length of a polar vector. </p>
<p>The returned value is <em>vector.r</em>. </p>

</div>
</div>
<a class="anchor" id="gadf28a44d32c67890cffbdb01de961260"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector2&lt;T&gt; thor::PerpendicularVector </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a perpendicular vector. </p>
<p>Returns <em>vector</em> turned by 90 degrees counter clockwise; (x,y) becomes (-y,x). For example, the vector (1,0) is transformed to (0,1). </p>

</div>
</div>
<a class="anchor" id="ga6ea1d819a159d8905957c4d04f53e3a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T thor::PolarAngle </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the angle between the projection of <em>vector</em> onto the XY-plane and the X-axis. </p>
<p>Example: The vector (1,0,z) corresponds 0 degrees, (0,1,z) corresponds 90 degrees, where z is arbitrary. </p>
<dl class="section return"><dt>Returns:</dt><dd>Angle in degrees in the interval [-180,180]. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd><em>vector</em> is no zero vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa7207e5e09fd8a27316a1e79568df4c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="group___vectors.html#gaa7207e5e09fd8a27316a1e79568df4c9">PolarAngle</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structthor_1_1_polar_vector2.html">PolarVector2</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td><code> [related]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the angle of a polar vector in degrees. </p>
<p>The returned value is <em>vector.phi</em>. </p>

</div>
</div>
<a class="anchor" id="ga5e0a54771f8f2cc23cf06be509a3d54b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T thor::PolarAngle </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the polar angle. </p>
<p>The vector (1,0) corresponds 0 degrees, (0,1) corresponds 90 degrees. </p>
<dl class="section return"><dt>Returns:</dt><dd>Angle in degrees in the interval [-180,180]. </dd></dl>
<dl class="section pre"><dt>Precondition:</dt><dd><em>vector</em> is no zero vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gab082b7ada7dcce3f6bf563f11dc63e51"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void thor::Rotate </td>
          <td>(</td>
          <td class="paramtype">sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rotates the vector by the given angle (in degrees). </p>
<p>The vector (1,0) corresponds 0 degrees, (0,1) corresponds 90 degrees. </p>

</div>
</div>
<a class="anchor" id="ga3b820024c1a5d34aa69975fc0f3bb654"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector2&lt;T&gt; thor::RotatedVector </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a copy of the vector, rotated by <em>angle</em> degrees. </p>
<p>The vector (1,0) corresponds 0 degrees, (0,1) corresponds 90 degrees. </p>

</div>
</div>
<a class="anchor" id="ga53d4235a898dae45a95151917492faac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void thor::SetLength </td>
          <td>(</td>
          <td class="paramtype">sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>newLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adapts <em>vector</em> so that its length is |<em>newLength|</em> after this operation. </p>
<p>If <em>newLength</em> is less than zero, the vector's direction changes. </p>
<dl class="section pre"><dt>Precondition:</dt><dd><em>vector</em> is no zero vector. </dd></dl>

</div>
</div>
<a class="anchor" id="ga5d1daa4962e7a4a429c20440163e0896"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void thor::SetPolarAngle </td>
          <td>(</td>
          <td class="paramtype">sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>newAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the polar angle of the specified vector. </p>
<p>The vector (1,0) corresponds 0 degrees, (0,1) corresponds 90 degrees. </p>

</div>
</div>
<a class="anchor" id="gaba5e60f43087543f22f8e8a3d5ba033a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T thor::SquaredLength </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the square of <em>vector's</em> length. </p>
<p>Suitable for comparisons, more efficient than <a class="el" href="group___vectors.html#gad9881856439c3c1973c373900cc9ea57" title="Returns the length of the 2D vector.">Length()</a>. </p>

</div>
</div>
<a class="anchor" id="ga1012c58d15fbdbb288516f31bfc726b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T thor::SquaredLength </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the square of <em>vector's</em> length. </p>
<p>Suitable for comparisons, more efficient than <a class="el" href="group___vectors.html#gad9881856439c3c1973c373900cc9ea57" title="Returns the length of the 2D vector.">Length()</a>. </p>

</div>
</div>
<a class="anchor" id="ga834f9b0351b354227928082828360131"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector3&lt;T&gt; thor::UnitVector </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector3&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector with same direction as the argument, but with length 1. </p>
<dl class="section pre"><dt>Precondition:</dt><dd><em>vector</em> is no zero vector. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf3b94d5a7158c94964f0bbb525cac15c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sf::Vector2&lt;T&gt; thor::UnitVector </td>
          <td>(</td>
          <td class="paramtype">const sf::Vector2&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a vector with same direction as the argument, but with length 1. </p>
<dl class="section pre"><dt>Precondition:</dt><dd><em>vector</em> is no zero vector. </dd></dl>

</div>
</div>
</div><!-- contents -->

<!--hr class="footer" /-->
<div id="footer">
  Copyright (c) Jan Haller 2011-2016
</div>
<!--
<address class="footer"><small>
Generated on Sat Jun 16 2012 16:43:44 for Thor by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0</small></address>
-->
</body>
</html>
