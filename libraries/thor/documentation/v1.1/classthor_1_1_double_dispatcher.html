<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>thor::DoubleDispatcher&lt; B, R &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<!--<script type="text/javascript" src="$relpath/search.js"></script>-->
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body> <!-- onload='searchBox.OnSelectItem(0);'> -->


<div id="header1"><img src="../../../../bromeon.png" alt="Bromeon"/>
</div>
<div class="sidebar">
  <p><a href="../../../../index.html">Home</a></p>
  <p><a href="../../../../libraries/index.html">C++ Libraries</a></p>
  <div class="sb-sub">
    <p><a href="../../../thor/index.html">Thor</a></p>
    <div class="sb-sub2">
      <div class="sb-cur">
        <p><a href="../../documentation.html">Documentation</a></p>
      </div>
      <p><a href="../../download.html">Download</a></p>
      <p><a href="../../tutorials.html">Tutorials</a></p>
    </div>
    <p><a href="../../../aurora/index.html">Aurora</a></p>
  </div>
  <p><a href="../../../../games/index.html">Games</a></p>
  <p><a href="../../../../contact.html">Contact</a></p>
</div>

<!--
<div id="header"><img src="Bromeon.png" alt="Bromeon" />
</div>
<div id="sidebar">
  <p><a href="index.html">Home</a></p>
  <p><a href="thor.html">Thor C++ Library</a></p>
  <p><a href="doc/index.html">Documentation</a></p>
<p>Tutorials</p>
<p>Downloads</p>
</div>
-->

<div id="top"><!-- do not remove this div! -->
<!-- Generated by Doxygen 1.8.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>thor</b>      </li>
      <li class="navelem"><a class="el" href="classthor_1_1_double_dispatcher.html">DoubleDispatcher</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">thor::DoubleDispatcher&lt; B, R &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___tools.html">Tools</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Class that is able to perform dynamic dispatch on multiple functions with two parameters.  
 <a href="classthor_1_1_double_dispatcher.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for thor::DoubleDispatcher&lt; B, R &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classthor_1_1_double_dispatcher__inherit__graph.png" border="0" usemap="#thor_1_1_double_dispatcher_3_01_b_00_01_r_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="thor_1_1_double_dispatcher_3_01_b_00_01_r_01_4_inherit__map" id="thor_1_1_double_dispatcher_3_01_b_00_01_r_01_4_inherit__map">
<area shape="rect" id="node2" href="classthor_1_1_non_copyable.html" title="Non&#45;copyable base class." alt="" coords="19,5,147,35"/>
</map>
</div>

<p><a href="classthor_1_1_double_dispatcher-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aff76a0f4958a1e559aba3ca8f4444a17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_double_dispatcher.html#aff76a0f4958a1e559aba3ca8f4444a17">DoubleDispatcher</a> (bool symmetric=true, bool supportDerivedToBase=false)</td></tr>
<tr class="memdesc:aff76a0f4958a1e559aba3ca8f4444a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#aff76a0f4958a1e559aba3ca8f4444a17"></a><br/></td></tr>
<tr class="memitem:a435dc9f9d25e16f88c595b226c06fde1"><td class="memTemplParams" colspan="2">template&lt;class D1 , class D2 &gt; </td></tr>
<tr class="memitem:a435dc9f9d25e16f88c595b226c06fde1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1">Register</a> (R(*globalFunction)(D1#, D2#))</td></tr>
<tr class="memdesc:a435dc9f9d25e16f88c595b226c06fde1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a global function.  <a href="#a435dc9f9d25e16f88c595b226c06fde1"></a><br/></td></tr>
<tr class="memitem:ab6c074516330a26517c75a1513fb3308"><td class="memTemplParams" colspan="2">template&lt;class D1 , class D2 , class C &gt; </td></tr>
<tr class="memitem:ab6c074516330a26517c75a1513fb3308"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthor_1_1_double_dispatcher.html#ab6c074516330a26517c75a1513fb3308">Register</a> (R(C::*memberFunction)(D1#, D2#), C &amp;object)</td></tr>
<tr class="memdesc:ab6c074516330a26517c75a1513fb3308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a member function.  <a href="#ab6c074516330a26517c75a1513fb3308"></a><br/></td></tr>
<tr class="memitem:a60537ddc8751ce38adf7fff53327e9b7"><td class="memTemplParams" colspan="2">template&lt;class D1 , class D2 , typename Fn &gt; </td></tr>
<tr class="memitem:a60537ddc8751ce38adf7fff53327e9b7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classthor_1_1_double_dispatcher.html#a60537ddc8751ce38adf7fff53327e9b7">Register</a> (const Fn &amp;functionObject)</td></tr>
<tr class="memdesc:a60537ddc8751ce38adf7fff53327e9b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a function object.  <a href="#a60537ddc8751ce38adf7fff53327e9b7"></a><br/></td></tr>
<tr class="memitem:a04f0482616301d0b83baaca06480aceb"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classthor_1_1_double_dispatcher.html#a04f0482616301d0b83baaca06480aceb">Call</a> (B arg1, B arg2) const </td></tr>
<tr class="memdesc:a04f0482616301d0b83baaca06480aceb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dispatches the dynamic types of <em>arg1</em> and <em>arg2</em> and invokes the corresponding function.  <a href="#a04f0482616301d0b83baaca06480aceb"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;class B, typename R = void&gt;<br/>
class thor::DoubleDispatcher&lt; B, R &gt;</h3>

<p>Class that is able to perform dynamic dispatch on multiple functions with two parameters. </p>
<p>Sometimes you encounter the situation where you need to implement polymorphic behavior to dispatch dynamically on more than one type. Like overloading functions with two parameters at compile time, this class allows you to perform a dispatch on two arguments at runtime. At invocation time, all you need is the static type of the base class, the DoubleDispatcher figures out which dynamic types match which function. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">B</td><td>Reference or pointer to polymorphic base class. This is the base class of every dispatched function's parameter type. When it is a pointer, the arguments of the dispatched functions shall be pointers too (the same applies to references). the dispatched functions shall have arguments of type pointer or reference to const, too. </td></tr>
    <tr><td class="paramname">R</td><td>Return type of the dispatched functions.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><pre class="fragment"> <span class="comment">// Example class hierarchy</span>
 <span class="keyword">class </span>Base { <span class="keyword">public</span>: <span class="keyword">virtual</span> ~Base() {} };
 <span class="keyword">class </span>Derived1 : <span class="keyword">public</span> Base {};
 <span class="keyword">class </span>Derived2 : <span class="keyword">public</span> Base {};

 <span class="comment">// Free functions for the derived types</span>
 <span class="keywordtype">void</span> Func(Derived1* lhs, Derived1* rhs);
 <span class="keywordtype">void</span> Func(Derived1* lhs, Derived2* rhs);
 <span class="keywordtype">void</span> Func(Derived2* lhs, Derived2* rhs);

 <span class="comment">// Create dispatcher and register functions</span>
 <a class="code" href="classthor_1_1_double_dispatcher.html" title="Class that is able to perform dynamic dispatch on multiple functions with two parameters.">thor::DoubleDispatcher&lt;Base*&gt;</a> dispatcher;
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived1, Derived1&gt;(&amp;Func);
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived1, Derived2&gt;(&amp;Func);
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived2, Derived2&gt;(&amp;Func);

 <span class="comment">// Invoke functions on base class pointer</span>
 Base* ptr = <span class="keyword">new</span> Derived1;
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a04f0482616301d0b83baaca06480aceb" title="Dispatches the dynamic types of arg1 and arg2 and invokes the corresponding function.">Call</a>(ptr, ptr); <span class="comment">// Invokes void Func(Derived1* lhs, Derived1* rhs);</span>
 <span class="keyword">delete</span> ptr;
</pre></div> </div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aff76a0f4958a1e559aba3ca8f4444a17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B, typename R = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classthor_1_1_double_dispatcher.html">thor::DoubleDispatcher</a>&lt; B, R &gt;::<a class="el" href="classthor_1_1_double_dispatcher.html">DoubleDispatcher</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>supportDerivedToBase</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">symmetric</td><td>Is true if the calls <b>fn(a,b)</b> and <b>fn(b,a)</b> are equivalent and it's enough to register one of both variants. Otherwise, both calls have to be registered separately and are resolved to different functions. </td></tr>
    <tr><td class="paramname">supportDerivedToBase</td><td>Specifies whether derived-to-base conversions are supported. If no function for a derived class is found, the dispatcher will look for functions taking base class parameters and upcast the arguments, if possible. You need to register the class hierarchy using the macros in <a class="el" href="_rtti_8hpp.html" title="Manual enhancements of Runtime Type Information.">Rtti.hpp</a>. On average, calls with derived-to-base conversions are as fast as direct matches, but this feature requires a small memory overhead. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a04f0482616301d0b83baaca06480aceb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B, typename R = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classthor_1_1_double_dispatcher.html">thor::DoubleDispatcher</a>&lt; B, R &gt;::<a class="el" href="classthor_1_1_double_dispatcher.html#a04f0482616301d0b83baaca06480aceb">Call</a> </td>
          <td>(</td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>arg1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>arg2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Dispatches the dynamic types of <em>arg1</em> and <em>arg2</em> and invokes the corresponding function. </p>
<p>Note that the argument's dynamic type must match <b>exactly</b> with the registered type, unless you enabled derived-to-base conversions in the constructor and specified the class hierarchy. In the latter case, the function with the best match is chosen for overload resolution. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arg1</td><td>First function argument. </td></tr>
    <tr><td class="paramname">arg2</td><td>Second function argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns:</dt><dd>The return value of the dispatched function, if any. </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classthor_1_1_function_call_exception.html" title="Exception class for failed function calls.">FunctionCallException</a></td><td>when no corresponding function is found, or if a call is ambiguous. Ambiguity emerges at derived-to-base conversions if multiple functions represent an equally good match for overload resolution. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a435dc9f9d25e16f88c595b226c06fde1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B, typename R = void&gt; </div>
<div class="memtemplate">
template&lt;class D1 , class D2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthor_1_1_double_dispatcher.html">thor::DoubleDispatcher</a>&lt; B, R &gt;::<a class="el" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1">Register</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(D1#, D2#)&#160;</td>
          <td class="paramname"><em>globalFunction</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a global function. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">D1</td><td>Type of the derived class for the first parameter. Must be explicitly specified. </td></tr>
    <tr><td class="paramname">D2</td><td>Type of the derived class for the second parameter. Must be explicitly specified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">globalFunction</td><td>Pointer to function to register.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that # is a placeholder for either &amp; or *. The types D1# and D2# have the same attributes as B (pointer, reference, const-qualification): For instance, <b>B=const Base&amp;</b> implies <b>D1#=const Derived1&amp;</b>. <br/>
 Example (class hierarchy and dispatcher declaration missing): </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Overloaded global or namespace-level functions</span>
 <span class="keywordtype">void</span> Func(Derived1&amp;, Derived1&amp;);
 <span class="keywordtype">void</span> Func(Derived1&amp;, Derived2&amp;);
 <span class="keywordtype">void</span> Func(Derived2&amp;, Derived2&amp;);

 <span class="comment">// Register functions</span>
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived1, Derived1&gt;(&amp;Func);
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived1, Derived2&gt;(&amp;Func);
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived2, Derived2&gt;(&amp;Func);
</pre></div> <dl class="section pre"><dt>Precondition:</dt><dd>A function taking two arguments of dynamic type D1 and D2 is not registered yet. </dd></dl>

</div>
</div>
<a class="anchor" id="ab6c074516330a26517c75a1513fb3308"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B, typename R = void&gt; </div>
<div class="memtemplate">
template&lt;class D1 , class D2 , class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthor_1_1_double_dispatcher.html">thor::DoubleDispatcher</a>&lt; B, R &gt;::<a class="el" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1">Register</a> </td>
          <td>(</td>
          <td class="paramtype">R(C::*)(D1#, D2#)&#160;</td>
          <td class="paramname"><em>memberFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a member function. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">D1</td><td>Type of the derived class for the first parameter. Must be explicitly specified. </td></tr>
    <tr><td class="paramname">D2</td><td>Type of the derived class for the second parameter. Must be explicitly specified. </td></tr>
    <tr><td class="paramname">C</td><td>Class that holds the member function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">memberFunction</td><td>Pointer to member function to register. </td></tr>
    <tr><td class="paramname">object</td><td>Reference to object on which the member function is invoked.</td></tr>
  </table>
  </dd>
</dl>
<p>Note that # is a placeholder for either &amp; or *. The types D1# and D2# have the same attributes as B (pointer, reference, const-qualification): For instance, <b>B=const Base&amp;</b> implies <b>D1#=const Derived1&amp;</b>. <br/>
 Example (class hierarchy and dispatcher declaration missing): </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Class with overloaded member functions</span>
 <span class="keyword">struct </span>MyClass
 {
     <span class="keywordtype">void</span> MemFunc(Derived1&amp;, Derived1&amp;);
     <span class="keywordtype">void</span> MemFunc(Derived1&amp;, Derived2&amp;);
     <span class="keywordtype">void</span> MemFunc(Derived2&amp;, Derived2&amp;);
 } obj;

 <span class="comment">// Register member functions</span>
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived1, Derived1&gt;(&amp;MyClass::MemFunc, obj);
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived1, Derived2&gt;(&amp;MyClass::MemFunc, obj);
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived2, Derived2&gt;(&amp;MyClass::MemFunc, obj);
</pre></div> <dl class="section pre"><dt>Precondition:</dt><dd>A function taking two arguments of dynamic type D1 and D2 is not registered yet. </dd></dl>

</div>
</div>
<a class="anchor" id="a60537ddc8751ce38adf7fff53327e9b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class B, typename R = void&gt; </div>
<div class="memtemplate">
template&lt;class D1 , class D2 , typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classthor_1_1_double_dispatcher.html">thor::DoubleDispatcher</a>&lt; B, R &gt;::<a class="el" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1">Register</a> </td>
          <td>(</td>
          <td class="paramtype">const Fn &amp;&#160;</td>
          <td class="paramname"><em>functionObject</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a function object. </p>
<dl class=""><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">D1</td><td>Type of the derived class for the first parameter. Must be explicitly specified. </td></tr>
    <tr><td class="paramname">D2</td><td>Type of the derived class for the second parameter. Must be explicitly specified. </td></tr>
    <tr><td class="paramname">Fn</td><td>Type of the function object. Can be deduced from the argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">functionObject</td><td>Functor to register.</td></tr>
  </table>
  </dd>
</dl>
<p>Incomplete example using a function object (you can also have separate functors for each function): </p>
<div class="fragment"><pre class="fragment"> <span class="comment">// Class for function objects</span>
 <span class="keyword">struct </span>Functor
 {
    <span class="keywordtype">void</span> operator() (Derived1&amp;, Derived1&amp;);
    <span class="keywordtype">void</span> operator() (Derived1&amp;, Derived2&amp;);
    <span class="keywordtype">void</span> operator() (Derived2&amp;, Derived2&amp;);
 };

 <span class="comment">// Register functor</span>
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived1, Derived1&gt;(Functor());
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived1, Derived2&gt;(Functor());
 dispatcher.<a class="code" href="classthor_1_1_double_dispatcher.html#a435dc9f9d25e16f88c595b226c06fde1" title="Registers a global function.">Register</a>&lt;Derived2, Derived2&gt;(Functor());
</pre></div> <dl class="section pre"><dt>Precondition:</dt><dd>A function taking two arguments of dynamic type D1 and D2 is not registered yet. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Tools/<a class="el" href="_double_dispatcher_8hpp_source.html">DoubleDispatcher.hpp</a></li>
</ul>
</div><!-- contents -->

<!--hr class="footer" /-->
<div id="footer">
  Copyright (c) Jan Haller 2011-2016
</div>
<!--
<address class="footer"><small>
Generated on Sat Jun 16 2012 16:43:44 for Thor by&#160;<a href="http://www.doxygen.org/index.html"><img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.0</small></address>
-->
</body>
</html>
